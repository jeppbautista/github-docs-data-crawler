<html><body><div>
<main><div>
<div><nav><ul>
<li>
<a title="Secure coding" href="/en/code-security">Secure coding</a><span>/</span>
</li>
<li>
<a title="CodeQL CLI" href="/en/code-security/codeql-cli">CodeQL CLI</a><span>/</span>
</li>
<li>
<a title="Getting started" href="/en/code-security/codeql-cli/getting-started-with-the-codeql-cli">Getting started</a><span>/</span>
</li>
<li><a title="Preparing code for analysis" href="/en/code-security/codeql-cli/getting-started-with-the-codeql-cli/preparing-your-code-for-codeql-analysis">Preparing code for analysis</a></li>
</ul></nav></div>
<div>
<div><div><h1>Preparing your code for CodeQL analysis</h1></div></div>
<div>
<div><p>You can build a CodeQL database containing the data needed to analyze your code.</p></div>
<div><div>
<div><h2>Who can use this feature?</h2></div>
<div><div><p>Users with <strong>read</strong> access to a repository</p></div></div>
<div><div>
<p>CodeQL is available for the following repository types:</p>
<ul>
<li>Public repositories on GitHub.com, see <a href="https://github.com/github/codeql-cli-binaries/blob/main/LICENSE.md">GitHub CodeQL Terms and Conditions</a>
</li>
<li>Organization-owned repositories on GitHub Team with <a href="/en/get-started/learning-about-github/about-github-advanced-security">GitHub Code Security</a> enabled</li>
</ul>
</div></div>
</div></div>
</div>
<div>
<h2>In this article</h2>
<nav><ul>
<li><a href="#about-preparing-your-code-for-analysis"><div><span>About preparing your code for analysis</span></div></a></li>
<li><a href="#running-codeql-database-create"><div><span>Running codeql database create</span></div></a></li>
<li><a href="#progress-and-results"><div><span>Progress and results</span></div></a></li>
<li><a href="#creating-databases-for-non-compiled-languages"><div><span>Creating databases for non-compiled languages</span></div></a></li>
<li><a href="#creating-databases-for-compiled-languages"><div><span>Creating databases for compiled languages</span></div></a></li>
<li><a href="#next-steps"><div><span>Next steps</span></div></a></li>
</ul></nav>
</div>
<div><div><div>
<h2><a href="#about-preparing-your-code-for-analysis">About preparing your code for analysis</a></h2>
<p>Before you analyze your code using CodeQL, you need to create a CodeQL database containing all the data required to run queries on your code. You can create CodeQL databases yourself using the CodeQL CLI.</p>
<p>CodeQL analysis relies on extracting relational data from your code, and using it to build a <a href="https://codeql.github.com/docs/codeql-overview/codeql-glossary/#codeql-database">CodeQL database</a>. CodeQL databases contain all of the important information about a codebase, which can be analyzed by executing CodeQL queries against it.</p>
<p>Before you generate a CodeQL database, you need to:</p>
<ol>
<li>Install and set up the CodeQL CLI. For more information, see <a href="/en/code-security/codeql-cli/getting-started-with-the-codeql-cli/setting-up-the-codeql-cli">Setting up the CodeQL CLI</a>.</li>
<li>Check out the code that you want to analyze:
<ul>
<li>For a branch, check out the head of the branch that you want to analyze.</li>
<li>For a pull request, check out either the head commit of the pull request, or check out a GitHub-generated merge commit of the pull request.</li>
</ul>
</li>
<li>Set up the environment for the codebase, making sure that any dependencies are available.</li>
<li>For the best results with compiled languages, find the build command, if any, for the codebase. Typically this is available in a configuration file in the CI system.</li>
</ol>
<p>Once the codebase is ready, you can run <code>codeql database create</code> to create the database. For more information, see <a href="#creating-databases-for-non-compiled-languages">Creating databases for non-compiled languages</a> and <a href="#creating-databases-for-compiled-languages">Creating databases for compiled languages</a>.</p>
<h2><a href="#running-codeql-database-create">Running <code>codeql database create</code></a></h2>
<p>CodeQL databases are created by running the following command from the checkout root of your project:</p>
<pre><code>codeql database create &lt;database&gt; --language=&lt;language-identifier&gt;
</code></pre>
<p>You must specify:</p>
<ul>
<li>
<p><code>&lt;database&gt;</code>: a path to the new database to be created. This directory will be created when you execute the command—you cannot specify an existing directory.</p>
</li>
<li>
<p><code>--language</code>: the identifier for the language to create a database for. When used with <code>--db-cluster</code>, the option accepts a comma-separated list, or can be specified more than once. CodeQL supports creating databases for the following languages:</p>

































































<table>
<thead><tr>
<th>Language</th>
<th>Identifier</th>
<th>Optional alternative identifiers (if any)</th>
</tr></thead>
<tbody>
<tr>
<td>C/C++</td>
<td><code>c-cpp</code></td>
<td>
<code>c</code> or <code>cpp</code>
</td>
</tr>
<tr>
<td>C#</td>
<td><code>csharp</code></td>
<td></td>
</tr>
<tr>
<td>Go</td>
<td><code>go</code></td>
<td></td>
</tr>
<tr>
<td>Java/Kotlin</td>
<td><code>java-kotlin</code></td>
<td>
<code>java</code> or <code>kotlin</code>
</td>
</tr>
<tr>
<td>JavaScript/TypeScript</td>
<td><code>javascript-typescript</code></td>
<td>
<code>javascript</code> or <code>typescript</code>
</td>
</tr>
<tr>
<td>Python</td>
<td><code>python</code></td>
<td></td>
</tr>
<tr>
<td>Ruby</td>
<td><code>ruby</code></td>
<td></td>
</tr>
<tr>
<td>Swift</td>
<td><code>swift</code></td>
<td></td>
</tr>
<tr>
<td>GitHub Actions workflows</td>
<td><code>actions</code></td>
<td></td>
</tr>
</tbody>
</table>
<div>
<p>
If you specify one of the alternative identifiers, this is equivalent to using the standard language identifier. For example, specifying <code>javascript</code> instead of <code>javascript-typescript</code> will not exclude analysis of TypeScript code. You can do this in an advanced setup workflow with the <code>--paths-ignore</code> option. For more information, see <a href="/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/customizing-your-advanced-setup-for-code-scanning#specifying-directories-to-scan">Customizing your advanced setup for code scanning</a>.</p>
</div>
</li>
</ul>
<p>If your codebase has a build command or script that invokes the build process, we recommend that you specify it as well:</p>
<pre><code>   codeql database create &lt;database&gt; --command &lt;build&gt; \
         --language=&lt;language-identifier&gt;
</code></pre>
<h3><a href="#options-for-creating-databases">Options for creating databases</a></h3>
<p>You can specify additional options depending on the location of your source file, if the code needs to be compiled, and if you want to create CodeQL databases for more than one language.</p>




























































<table>
<thead><tr>
<th>Option</th>
<th>Required</th>
<th>Usage</th>
</tr></thead>
<tbody>
<tr>
<td><code>&lt;database&gt;</code></td>
<td></td>
<td>Specify the name and location of a directory to create for the CodeQL database. The command will fail if you try to overwrite an existing directory. If you also specify <code>--db-cluster</code>, this is the parent directory and a subdirectory is created for each language analyzed.</td>
</tr>
<tr>
<td><code><span>--language</span></code></td>
<td></td>
<td>Specify the identifier for the language to create a database for, one of: <code>c-cpp</code>, <code>csharp</code>, <code>go</code>, <code>java-kotlin</code>, <code>javascript-typescript</code>, <code>python</code>, <code>ruby</code>, and <code>swift</code>. When used with <code><span>--db-cluster</span></code>, the option accepts a comma-separated list, or can be specified more than once.</td>
</tr>
<tr>
<td><code><span>--command</span></code></td>
<td></td>
<td>
<strong>Recommended.</strong> Use to specify the build command or script that invokes the build process for the codebase. Commands are run from the current folder or, where it is defined, from <code><span>--source-root</span></code>. Not needed for Python and JavaScript/TypeScript analysis.</td>
</tr>
<tr>
<td><code><span>--build-mode</span></code></td>
<td></td>
<td>
<strong>Recommended.</strong> Use for C# and Java when not providing a <code>--command</code> to specify whether to create a CodeQL database without a build (<code>none</code>) or by attempting to automatically detect a build command (<code>autobuild</code>). By default, autobuild detection is used. For a comparison of build modes, see <a href="/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/codeql-code-scanning-for-compiled-languages#codeql-build-modes">CodeQL build modes</a>.</td>
</tr>
<tr>
<td><code><span>--db-cluster</span></code></td>
<td></td>
<td>Use in multi-language codebases to generate one database for each language specified by <code><span>--language</span></code>.</td>
</tr>
<tr>
<td><code><span>--no-run-unnecessary-builds</span></code></td>
<td></td>
<td>
<strong>Recommended.</strong> Use to suppress the build command for languages where the CodeQL CLI does not need to monitor the build (for example, Python and JavaScript/TypeScript).</td>
</tr>
<tr>
<td><code><span>--source-root</span></code></td>
<td></td>
<td>Use if you run the CLI outside the checkout root of the repository. By default, the <code>database create</code> command assumes that the current directory is the root directory for the source files, use this option to specify a different location.</td>
</tr>
<tr>
<td><code><span>--codescanning-config</span></code></td>
<td></td>
<td>Advanced. Use if you have a configuration file that specifies how to create the CodeQL databases and what queries to run in later steps. For more information, see <a href="/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/customizing-your-advanced-setup-for-code-scanning#using-a-custom-configuration-file">Customizing your advanced setup for code scanning</a> and <a href="/en/code-security/codeql-cli/codeql-cli-manual/database-create#--codescanning-configfile">database create</a>.</td>
</tr>
</tbody>
</table>
<p>You can specify extractor options to customize the behavior of extractors that create CodeQL databases. For more information, see
<a href="/en/code-security/codeql-cli/using-the-advanced-functionality-of-the-codeql-cli/extractor-options">Extractor options</a>.</p>
<p>For full details of all the options you can use when creating databases, see <a href="/en/code-security/codeql-cli/codeql-cli-manual/database-create">database create</a>.</p>
<h3><a href="#single-language-example">Single language example</a></h3>
<p>This example creates a single CodeQL database for the repository checked out at <code>/checkouts/example-repo</code>. It uses the JavaScript extractor to create a hierarchical representation of the JavaScript and TypeScript code in the repository. The resulting database is stored in <code>/codeql-dbs/example-repo</code>.</p>
<pre><code><span>$ </span><span>codeql database create /codeql-dbs/example-repo --language=javascript-typescript \
    --source-root /checkouts/example-repo</span>
<span>
&gt; </span><span>Initializing database at /codeql-dbs/example-repo.</span>
<span>&gt; </span><span>Running <span>command</span> [/codeql-home/codeql/javascript/tools/autobuild.cmd]</span>
    in /checkouts/example-repo.
<span>&gt; </span><span>[build-stdout] Single-threaded extraction.</span>
<span>&gt; </span><span>[build-stdout] Extracting</span>
...
<span>&gt; </span><span>Finalizing database at /codeql-dbs/example-repo.</span>
<span>&gt; </span><span>Successfully created database at /codeql-dbs/example-repo.</span>
</code></pre>
<h3><a href="#multiple-language-example">Multiple language example</a></h3>
<p>This example creates two CodeQL databases for the repository checked out at <code>/checkouts/example-repo-multi</code>. It uses:</p>
<ul>
<li>
<code>--db-cluster</code> to request analysis of more than one language.</li>
<li>
<code>--language</code> to specify which languages to create databases for.</li>
<li>
<code>--command</code> to tell the tool the build command for the codebase, here <code>make</code>.</li>
<li>
<code>--no-run-unnecessary-builds</code> to tell the tool to skip the build command for languages where it is not needed (like Python).</li>
</ul>
<p>The resulting databases are stored in <code>python</code> and <code>cpp</code> subdirectories of <code>/codeql-dbs/example-repo-multi</code>.</p>
<pre><code><span>$ </span><span>codeql database create /codeql-dbs/example-repo-multi \
    --db-cluster --language python,c-cpp \
    --<span>command</span> make --no-run-unnecessary-builds \
    --source-root /checkouts/example-repo-multi</span>
Initializing databases at /codeql-dbs/example-repo-multi.
Running build command: [make]
[build-stdout] Calling python3 /codeql-bundle/codeql/python/tools/get_venv_lib.py
[build-stdout] Calling python3 -S /codeql-bundle/codeql/python/tools/python_tracer.py -v -z all -c /codeql-dbs/example-repo-multi/python/working/trap_cache -p ERROR: 'pip' not installed.
[build-stdout] /usr/local/lib/python3.6/dist-packages -R /checkouts/example-repo-multi
[build-stdout] [INFO] Python version 3.6.9
[build-stdout] [INFO] Python extractor version 5.16
[build-stdout] [INFO] [2] Extracted file /checkouts/example-repo-multi/hello.py in 5ms
[build-stdout] [INFO] Processed 1 modules in 0.15s
[build-stdout] &lt;output from calling 'make' to build the C/C++ code&gt;
Finalizing databases at /codeql-dbs/example-repo-multi.
Successfully created databases at /codeql-dbs/example-repo-multi.
<span>$</span></code></pre>
<h2><a href="#progress-and-results">Progress and results</a></h2>
<p>Errors are reported if there are any problems with the options you have specified. For interpreted languages and when you specify <code>--build-mode none</code> for C# and Java, the extraction progress is displayed in the console. For each source file, the console shows if extraction was successful or if it failed. When a compiled language is built, the console will display the output of the build system.</p>
<p>When the database is successfully created, you’ll find a new directory at the path specified in the command. If you used the <code>--db-cluster</code> option to create more than one database, a subdirectory is created for each language. Each CodeQL database directory contains a number of subdirectories, including the relational data (required for analysis) and a source archive—a copy of the source files made at the time the database was created—which is used for displaying analysis results.</p>
<h2><a href="#creating-databases-for-non-compiled-languages">Creating databases for non-compiled languages</a></h2>
<p>The CodeQL CLI includes extractors to create databases for non-compiled languages—specifically, JavaScript (and TypeScript), Python, and Ruby. These extractors are automatically invoked when you specify JavaScript, Python, or Ruby as the <code>--language</code> option when executing <code>database create</code>. When creating databases for these languages you must ensure that all additional dependencies are available.</p>
<div>
<p>
When you run <code>database create</code> for JavaScript, TypeScript, Python, and Ruby, you should not specify a <code>--command</code> option. Otherwise this overrides the normal extractor invocation, which will create an empty database. If you create databases for multiple languages and one of them is a compiled language, use the <code>--no-run-unnecessary-builds</code> option to skip the command for the languages that don’t need to be compiled.</p>
</div>
<h3><a href="#javascript-and-typescript">JavaScript and TypeScript</a></h3>
<p>Creating databases for JavaScript requires no additional dependencies, but if the project includes TypeScript files, Node.js 14 or higher must be installed and available on the <code>PATH</code> as <code>node</code>. In the command line you can specify <code>--language=javascript-typescript</code> to extract both JavaScript and TypeScript files:</p>
<pre><code>codeql database create --language=javascript-typescript --source-root &lt;folder-to-extract&gt; &lt;output-folder&gt;/javascript-database
</code></pre>
<p>Here, we have specified a <code>--source-root</code> path, which is the location where database creation is executed, but is not necessarily the checkout root of the codebase.</p>
<p>By default, files in <code>node_modules</code> and <code>bower_components</code> directories are not extracted.</p>
<h3><a href="#python">Python</a></h3>
<p>When creating databases for Python you must ensure:</p>
<ul>
<li>You have Python 3 installed and available to the CodeQL extractor.</li>
<li>You have the version of Python used by your code installed.</li>
</ul>
<p>In the command line you must specify <code>--language=python</code>. For example:</p>
<pre><code>codeql database create --language=python &lt;output-folder&gt;/python-database
</code></pre>
<p>This executes the <code>database create</code> subcommand from the code’s checkout root, generating a new Python database at <code>&lt;output-folder&gt;/python-database</code>.</p>
<h3><a href="#ruby">Ruby</a></h3>
<p>Creating databases for Ruby requires no additional dependencies. In the command line you must specify <code>--language=ruby</code>. For example:</p>
<pre><code>codeql database create --language=ruby --source-root &lt;folder-to-extract&gt; &lt;output-folder&gt;/ruby-database
</code></pre>
<p>Here, we have specified a <code>--source-root</code> path, which is the location where database creation is executed, but is not necessarily the checkout root of the codebase.</p>
<h2><a href="#creating-databases-for-compiled-languages">Creating databases for compiled languages</a></h2>
<p>For most compiled languages, CodeQL needs to invoke the required build system to generate a database, therefore the build method must be available to the CLI. This approach creates databases that include generated code. CodeQL has two methods for building codebases:</p>
<ul>
<li><a href="#automatically-detecting-the-build-system">Automatic build detection (autobuild)</a></li>
<li><a href="/en/code-security/codeql-cli/getting-started-with-the-codeql-cli/preparing-your-code-for-codeql-analysis#specifying-build-commands">User-specified build commands</a></li>
</ul>
<p>In addition, for C# and Java, there is an option to generate a database without building the code. This is particularly useful when you want to enable code scanning for many repositories. For more information, see <a href="/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/codeql-code-scanning-for-compiled-languages#codeql-build-modes">CodeQL build modes</a>.</p>
<h3><a href="#automatically-detecting-the-build-system">Automatically detecting the build system</a></h3>
<p>The CodeQL CLI includes autobuilders for C/C++, C#, Go, Java, Kotlin, and Swift code. CodeQL autobuilders allow you to build projects for compiled languages without specifying any build commands. When an autobuilder is invoked, CodeQL examines the source for evidence of a build system and attempts to run the optimal set of commands required to extract a database. For more information, see <a href="/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/codeql-code-scanning-for-compiled-languages#about-autobuild">CodeQL code scanning for compiled languages</a>.</p>
<p>An autobuilder is invoked automatically when you execute <code>codeql database create</code> for a compiled language if you don’t include a
<code>--command</code> option or set <code>--build-mode none</code>. For example, for a C/C++ codebase, you could simply run:</p>
<pre><code>codeql database create --language=cpp &lt;output-folder&gt;/cpp-database
</code></pre>
<p>If a codebase uses a standard build system, relying on an autobuilder is often the simplest way to create a database. For sources that require non-standard build steps, you may need to explicitly define each step in the command line.</p>
<div>
<ul>
<li>If you are building a Go database, install the Go toolchain (version 1.11 or later) and, if there are dependencies, the appropriate dependency manager (such as <a href="https://golang.github.io/dep/">dep</a>).</li>
<li>The Go autobuilder attempts to automatically detect code written in Go in a repository, and only runs build scripts in an attempt to fetch dependencies. To force CodeQL to limit extraction to the files compiled by your build script, set the environment variable <code>CODEQL_EXTRACTOR_GO_BUILD_TRACING=on</code> or use the <code>--command</code> option to specify a build command.</li>
</ul>
</div>
<h3><a href="#specifying-build-commands">Specifying build commands</a></h3>
<p>The following examples are designed to give you an idea of some of the build commands that you can specify for compiled languages.</p>
<div>
<p>
The <code>--command</code> option accepts a single argument—if you need to use more than one command, specify <code>--command</code> multiple times. If you need to pass subcommands and options, the whole argument needs to be quoted to be interpreted correctly.</p>
</div>
<ul>
<li>
<p>C/C++ project built using <code>make</code>:</p>
<pre><code><span># </span><span>Disable parallel execution via `-j1` or other techniques: https://www.gnu.org/software/make/manual/make.html<span>#Parallel-Execution</span></span>
codeql database create cpp-database --language=c-cpp --command=make
</code></pre>
</li>
<li>
<p>C# project built using <code>dotnet build</code>:</p>
<p>It is a good idea to add <code>/t:rebuild</code> to ensure that all code will be built, or do a prior <code>dotnet clean</code> (code that is not built will not be included in the CodeQL database):</p>
<pre><code>codeql database create csharp-database --language=csharp --command='dotnet build /t:rebuild'
</code></pre>
</li>
<li>
<p>Go project built using the <code>CODEQL_EXTRACTOR_GO_BUILD_TRACING=on</code> environment variable:</p>
<pre><code>CODEQL_EXTRACTOR_GO_BUILD_TRACING=on codeql database create go-database --language=go
</code></pre>
</li>
<li>
<p>Go project built using a custom build script:</p>
<pre><code>codeql database create go-database --language=go --command='./scripts/build.sh'
</code></pre>
</li>
<li>
<p>Java project built using Gradle:</p>
<pre><code><span># </span><span>Use `--no-daemon` because a build delegated to an existing daemon cannot be detected by CodeQL.</span>
<span># </span><span>To ensure isolated builds without caching, add `--no-build-cache` on persistent machines.</span>
codeql database create java-database --language=java-kotlin --command='gradle --no-daemon clean test'
</code></pre>
</li>
<li>
<p>Java project built using Maven:</p>
<pre><code>codeql database create java-database --language=java-kotlin --command='mvn clean install'
</code></pre>
</li>
<li>
<p>Java project built using Ant:</p>
<pre><code>codeql database create java-database --language=java-kotlin --command='ant -f build.xml'
</code></pre>
</li>
<li>
<p>Swift project built from an Xcode project or workspace. By default, the largest Swift target is built:</p>
<p>It's a good idea to ensure that the project is in a clean state and that there are no build artifacts available.</p>
<pre><code>xcodebuild clean -all
codeql database create -l swift swift-database
</code></pre>
</li>
<li>
<p>Swift project built with <code>swift build</code>:</p>
<pre><code>codeql database create -l swift -c "swift build" swift-database
</code></pre>
</li>
<li>
<p>Swift project built with <code>xcodebuild</code>:</p>
<pre><code>codeql database create -l swift -c "xcodebuild build -target your-target" swift-database
</code></pre>
<p>You can pass the <code>archive</code> and <code>test</code> options to <code>xcodebuild</code>. However, the standard <code>xcodebuild</code> command is recommended as it should be the fastest, and should be all that CodeQL requires for a successful scan.</p>
</li>
<li>
<p>Swift project built using a custom build script:</p>
<pre><code>codeql database create -l swift -c "./scripts/build.sh" swift-database
</code></pre>
</li>
<li>
<p>Project built using Bazel:</p>
<pre><code><span># </span><span>Navigate to the Bazel workspace.</span>
<span>
# </span><span>Before building, remove cached objects</span>
<span># </span><span>and stop all running Bazel server processes.</span>
bazel clean --expunge
<span>
# </span><span>Build using the following Bazel flags, to <span>help</span> CodeQL detect the build:</span>
<span># </span><span>`--spawn_strategy=<span>local</span>`: build locally, instead of using a distributed build</span>
<span># </span><span>`--nouse_action_cache`: turn off build caching, <span>which</span> might prevent recompilation of <span>source</span> code</span>
<span># </span><span>`--noremote_accept_cached`, `--noremote_upload_local_results`: avoid using a remote cache</span>
<span># </span><span>`--disk_cache=`: avoid using a disk cache. Note that a disk cache is no longer considered a remote cache as of Bazel 6.</span>
codeql database create new-database --language=&lt;language&gt; \
--command='bazel build --spawn_strategy=local --nouse_action_cache --noremote_accept_cached --noremote_upload_local_results --disk_cache= //path/to/package:target'
<span>
# </span><span>After building, stop all running Bazel server processes.</span>
<span># </span><span>This ensures future build commands start <span>in</span> a clean Bazel server process</span>
<span># </span><span>without CodeQL attached.</span>
bazel shutdown
</code></pre>
</li>
<li>
<p>Project built using a custom build script:</p>
<pre><code>codeql database create new-database --language=&lt;language&gt; --command='./scripts/build.sh'
</code></pre>
</li>
</ul>
<p>This command runs a custom script that contains all of the commands required to build the project.</p>
<p><a></a></p>
<h3><a href="#using-indirect-build-tracing">Using indirect build tracing</a></h3>
<p>If the CodeQL CLI autobuilders for compiled languages do not work with your CI workflow and you cannot wrap invocations of build commands with <code>codeql database trace-command</code>, you can use indirect build tracing to create a CodeQL database. To use indirect build tracing, your CI system must be able to set custom environment variables for each build action.</p>
<p>To create a CodeQL database with indirect build tracing, run the following command from the checkout root of your project:</p>
<pre><code>codeql database init ... --begin-tracing &lt;database&gt;
</code></pre>
<p>You must specify:</p>
<ul>
<li>
<code>&lt;database&gt;</code>: a path to the new database to be created. This directory will be created when you execute the command—you cannot specify an existing directory.</li>
<li>
<code>--begin-tracing</code>: creates scripts that can be used to set up an environment in which build commands will be traced.</li>
</ul>
<p>You may specify other options for the <code>codeql database init</code> command as normal.</p>
<div>
<p>
If the build runs on Windows, you must set either <code>--trace-process-level &lt;number&gt;</code> or <code>--trace-process-name &lt;parent process name&gt;</code> so that the option points to a parent CI process that will observe all build steps for the code being analyzed.</p>
</div>
<p>The <code>codeql database init</code> command will output a message:</p>
<pre><code>Created skeleton &lt;database&gt;. This in-progress database is ready to be populated by an extractor. In order to initialise tracing, some environment variables need to be set in the shell your build will run in. A number of scripts to do this have been created in &lt;database&gt;/temp/tracingEnvironment. Please run one of these scripts before invoking your build command.

Based on your operating system, we recommend you run: ...
</code></pre>
<p>The <code>codeql database init</code> command creates <code>&lt;database&gt;/temp/tracingEnvironment</code> with files that contain environment variables and values that will enable CodeQL to trace a sequence of build steps. These files are named <code>start-tracing.{json,sh,bat,ps1}</code>. Use one of these files with your CI system’s mechanism for setting environment variables for future steps. You can:</p>
<ul>
<li>Read the JSON file, process it, and print out environment variables in the format expected by your CI system. For example, Azure DevOps expects <code>echo "##vso[task.setvariable variable=NAME]VALUE"</code>.</li>
<li>Or, if your CI system persists the environment, source the appropriate <code>start-tracing</code> script to set the CodeQL variables in the shell environment of the CI system.</li>
</ul>
<p>Build your code; optionally, unset the environment variables using an <code>end-tracing.{json,sh,bat,ps1}</code> script from the directory where the <code>start-tracing</code> scripts are stored; and then run the command <code>codeql database finalize &lt;database&gt;</code>.</p>
<p>Once you have created a CodeQL database using indirect build tracing, you can work with it like any other CodeQL database. For example, analyze the database, and upload the results to GitHub if you use code scanning.</p>
<h3><a href="#example-of-creating-a-codeql-database-using-indirect-build-tracing">Example of creating a CodeQL database using indirect build tracing</a></h3>
<div>
<p>
If you use Azure DevOps pipelines, the simplest way to create a CodeQL database is to use GitHub Advanced Security for Azure DevOps. For documentation, see <a href="https://learn.microsoft.com/en-us/azure/devops/repos/security/configure-github-advanced-security-features">Configure GitHub Advanced Security for Azure DevOps</a> in Microsoft Learn.</p>
</div>
<p>The following example shows how you could use indirect build tracing in an Azure DevOps pipeline to create a CodeQL database:</p>
<pre><code><span>steps:</span>
    <span># Download the CodeQL CLI and query packs...</span>
    <span># Check out the repository ...</span>

    <span># Run any pre-build tasks, for example, restore NuGet dependencies...</span>

    <span># Initialize the CodeQL database.</span>
    <span># In this example, the CodeQL CLI has been downloaded and placed on the PATH.</span>
    <span>-</span> <span>task:</span> <span>CmdLine@1</span>
       <span>displayName:</span> <span>Initialize</span> <span>CodeQL</span> <span>database</span>
      <span>inputs:</span>
          <span># Assumes the source code is checked out to the current working directory.</span>
          <span># Creates a database at `&lt;current working directory&gt;/db`.</span>
          <span># Running on Windows, so specifies a trace process level.</span>
          <span>script:</span> <span>"codeql database init --language csharp --trace-process-name Agent.Worker.exe --source-root . --begin-tracing db"</span>

    <span># Read the generated environment variables and values,</span>
    <span># and set them so they are available for subsequent commands</span>
    <span># in the build pipeline. This is done in PowerShell in this example.</span>
    <span>-</span> <span>task:</span> <span>PowerShell@1</span>
       <span>displayName:</span> <span>Set</span> <span>CodeQL</span> <span>environment</span> <span>variables</span>
       <span>inputs:</span>
          <span>targetType:</span> <span>inline</span>
          <span>script:</span> <span>&gt;
             $json = Get-Content $(System.DefaultWorkingDirectory)/db/temp/tracingEnvironment/start-tracing.json | ConvertFrom-Json
             $json.PSObject.Properties | ForEach-Object {
                 $template = "##vso[task.setvariable variable="
                 $template += $_.Name
                 $template += "]"
                 $template += $_.Value
                 echo "$template"
             }
</span>
    <span># Execute the pre-defined build step. Note the `msbuildArgs` variable.</span>
    <span>-</span> <span>task:</span> <span>VSBuild@1</span>
        <span>inputs:</span>
          <span>solution:</span> <span>'**/*.sln'</span>
          <span>msbuildArgs:</span> <span>/p:OutDir=$(Build.ArtifactStagingDirectory)</span>
          <span>platform:</span> <span>Any</span> <span>CPU</span>
          <span>configuration:</span> <span>Release</span>
          <span># Execute a clean build, in order to remove any existing build artifacts prior to the build.</span>
          <span>clean:</span> <span>True</span>
       <span>displayName:</span> <span>Visual</span> <span>Studio</span> <span>Build</span>

    <span># Read and set the generated environment variables to end build tracing. This is done in PowerShell in this example.</span>
    <span>-</span> <span>task:</span> <span>PowerShell@1</span>
       <span>displayName:</span> <span>Clear</span> <span>CodeQL</span> <span>environment</span> <span>variables</span>
       <span>inputs:</span>
          <span>targetType:</span> <span>inline</span>
          <span>script:</span> <span>&gt;
             $json = Get-Content $(System.DefaultWorkingDirectory)/db/temp/tracingEnvironment/end-tracing.json | ConvertFrom-Json
             $json.PSObject.Properties | ForEach-Object {
                 $template = "##vso[task.setvariable variable="
                 $template += $_.Name
                 $template += "]"
                 $template += $_.Value
                 echo "$template"
             }
</span>
    <span>-</span> <span>task:</span> <span>CmdLine@2</span>
       <span>displayName:</span> <span>Finalize</span> <span>CodeQL</span> <span>database</span>
       <span>inputs:</span>
          <span>script:</span> <span>'codeql database finalize db'</span>

    <span># Other tasks go here, for example:</span>
    <span># `codeql database analyze`</span>
    <span># then `codeql github upload-results` ...</span>
</code></pre>
<h2><a href="#next-steps">Next steps</a></h2>
<ul>
<li>To learn how to use the CodeQL CLI to analyze the database you created from your code, see <a href="/en/code-security/codeql-cli/getting-started-with-the-codeql-cli/analyzing-your-code-with-codeql-queries">Analyzing your code with CodeQL queries</a>.</li>
</ul>
</div></div></div>
</div>
</div></main>
</div></body></html>