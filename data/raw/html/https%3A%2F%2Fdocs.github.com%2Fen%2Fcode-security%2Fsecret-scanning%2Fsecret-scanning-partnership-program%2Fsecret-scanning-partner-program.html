<html><body><div>
<main><div>
<div><nav><ul>
<li>
<a title="Secure coding" href="/en/code-security">Secure coding</a><span>/</span>
</li>
<li>
<a title="Secret scanning" href="/en/code-security/secret-scanning">Secret scanning</a><span>/</span>
</li>
<li>
<a title="Partner program" href="/en/code-security/secret-scanning/secret-scanning-partnership-program">Partner program</a><span>/</span>
</li>
<li><a title="Partner program" href="/en/code-security/secret-scanning/secret-scanning-partnership-program/secret-scanning-partner-program">Partner program</a></li>
</ul></nav></div>
<div>
<div><div><h1>Secret scanning partner program</h1></div></div>
<div>
<div><p>As a service provider, you can partner with GitHub to have your secret token formats secured through secret scanning, which searches for accidental commits of your secret format and can be sent to a service provider's verify endpoint.</p></div>
<div><div>
<div><h2>Who can use this feature?</h2></div>
<div><div>
<p>Secret scanning alerts for partners runs by default on the following repositories:</p>
<ul>
<li>Public repositories and public npm packages on GitHub</li>
</ul>
</div></div>
</div></div>
</div>
<div>
<h2>In this article</h2>
<nav><ul>
<li><a href="#the-secret-scanning-process"><div><span>The secret scanning process</span></div></a></li>
<li><a href="#joining-the-secret-scanning-program-on-github"><div><span>Joining the secret scanning program on GitHub</span></div></a></li>
</ul></nav>
</div>
<div><div><div>
<p>GitHub scans repositories for known secret formats to prevent fraudulent use of credentials that were committed accidentally. Secret scanning happens by default on public repositories and public npm packages. Repository administrators and organization owners can also enable secret scanning on private repositories. As a service provider, you can partner with GitHub so that your secret formats are included in our secret scanning.</p>
<p>When a match of your secret format is found in a public source, a payload is sent to an HTTP endpoint of your choice.</p>
<p>When a match of your secret format is found in a private repository configured for secret scanning, then repository admins and the committer are alerted and can view and manage the secret scanning result on GitHub. For more information, see <a href="/en/code-security/secret-scanning/managing-alerts-from-secret-scanning">Managing alerts from secret scanning</a>.</p>
<p>This article describes how you can partner with GitHub as a service provider and join the secret scanning partner program.</p>
<h2><a href="#the-secret-scanning-process">The secret scanning process</a></h2>
<p>The following diagram summarizes the secret scanning process for public repositories, with any matches sent to a service provider's verify endpoint. A similar process sends service providers tokens exposed in public packages on the npm registry.</p>
<p><picture><source><img src="/assets/cb-89330/images/help/security/secret-scanning-flow.png" alt="Diagram showing the process of scanning for a secret and sending matches to a service provider's verify endpoint."></source></picture></p>
<h2><a href="#joining-the-secret-scanning-program-on-github">Joining the secret scanning program on GitHub</a></h2>
<ol>
<li>Contact GitHub to get the process started.</li>
<li>Identify the relevant secrets you want to scan for and create regular expressions to capture them. For more detailed information and recommendations, see <a href="#identify-your-secrets-and-create-regular-expressions">Identify your secrets and create regular expressions</a> below.</li>
<li>For secret matches found publicly, create a secret alert service which accepts webhooks from GitHub that contain the secret scanning message payload.</li>
<li>Implement signature verification in your secret alert service.</li>
<li>Implement secret revocation and user notification in your secret alert service.</li>
<li>Provide feedback for false positives (optional).</li>
</ol>
<h3><a href="#contact-github-to-get-the-process-started">Contact GitHub to get the process started</a></h3>
<p>To get the enrollment process started, email <a href="mailto:secret-scanning@github.com"></a><a href="mailto:secret-scanning@github.com">secret-scanning@github.com</a>.</p>
<p>You will receive details on the secret scanning program, and you will need to agree to GitHub's terms of participation before proceeding.</p>
<h3><a href="#identify-your-secrets-and-create-regular-expressions">Identify your secrets and create regular expressions</a></h3>
<p>To scan for your secrets, GitHub needs the following pieces of information for each secret that you want included in the secret scanning program:</p>
<ul>
<li>
<p>A unique, human-readable name for the secret type. We'll use this to generate the <code>Type</code> value in the message payload later.</p>
</li>
<li>
<p>A regular expression which finds the secret type. We recommend you are as precise as possible, because this will help reduce the number of false positives. Some best practices for high quality, identifiable secrets are:</p>
<ul>
<li>A uniquely defined prefix</li>
<li>High entropy random strings</li>
<li>A 32-bit checksum</li>
</ul>
<p><picture><source><img src="/assets/cb-18925/images/help/security/regular-expression-guidance.png" alt="Screenshot showing the breakdown of a secret into a prefix and a 32-bit checksum."></source></picture></p>
</li>
<li>
<p>A test account for your service. This will allow us to generate and analyze examples of the secrets, further reducing false positives.</p>
</li>
<li>
<p>The URL of the endpoint that receives messages from GitHub. The URL doesn't have to be unique for each secret type.</p>
</li>
</ul>
<p>Send this information to <a href="mailto:secret-scanning@github.com"></a><a href="mailto:secret-scanning@github.com">secret-scanning@github.com</a>.</p>
<h3><a href="#create-a-secret-alert-service">Create a secret alert service</a></h3>
<p>Create a public, internet accessible HTTP endpoint at the URL you provided to us. When a match of your regular expression is found publicly, GitHub will send an HTTP <code>POST</code> message to your endpoint.</p>
<h4><a href="#example-request-body">Example request body</a></h4>
<pre><code><span>[</span>
  <span>{</span>
    <span>"token"</span><span>:</span><span>"NMIfyYncKcRALEXAMPLE"</span><span>,</span>
    <span>"type"</span><span>:</span><span>"mycompany_api_token"</span><span>,</span>
    <span>"url"</span><span>:</span><span>"https://github.com/octocat/Hello-World/blob/12345600b9cbe38a219f39a9941c9319b600c002/foo/bar.txt"</span><span>,</span>
    <span>"source"</span><span>:</span><span>"content"</span>
  <span>}</span>
<span>]</span>
</code></pre>
<p>The message body is a JSON array that contains one or more objects, with each object representing a single secret match. Your endpoint should be able to handle requests with a large number of matches without timing out. The keys for each secret match are:</p>
<ul>
<li>
<strong>token:</strong> The value of the secret match.</li>
<li>
<strong>type:</strong> The unique name you provided to identify your regular expression.</li>
<li>
<strong>url:</strong> The public URL where the match was found (may be empty)</li>
<li>
<strong>source:</strong> Where the token was found on GitHub.</li>
</ul>
<p>The list of valid values for <code>source</code> are:</p>
<ul>
<li>Content</li>
<li>Commit</li>
<li>Pull_request_title</li>
<li>Pull_request_description</li>
<li>Pull_request_comment</li>
<li>Issue_title</li>
<li>Issue_description</li>
<li>Issue_comment</li>
<li>Discussion_title</li>
<li>Discussion_body</li>
<li>Discussion_comment</li>
<li>Commit_comment</li>
<li>Gist_content</li>
<li>Gist_comment</li>
<li>Npm</li>
<li>Unknown</li>
</ul>
<h3><a href="#implement-signature-verification-in-your-secret-alert-service">Implement signature verification in your secret alert service</a></h3>
<p>The HTTP request to your service will also contain headers that we strongly recommend using
to validate the messages you receive are genuinely from GitHub, and are not malicious.</p>
<p>The two HTTP headers to look for are:</p>
<ul>
<li>
<code>Github-Public-Key-Identifier</code>: Which <code>key_identifier</code> to use from our API</li>
<li>
<code>Github-Public-Key-Signature</code>: Signature of the payload</li>
</ul>
<p>You can retrieve the GitHub secret scanning public key from <a href="https://api.github.com/meta/public_keys/secret_scanning">https://api.github.com/meta/public_keys/secret_scanning</a> and validate the message using the <code>ECDSA-NIST-P256V1-SHA256</code> algorithm. The endpoint
will provide several <code>key_identifier</code> and public keys. You can determine which public
key to use based on the value of <code>Github-Public-Key-Identifier</code>.</p>
<div>
<p>
When you send a request to the public key endpoint above, you may hit rate limits. To avoid hitting rate limits, you can use a personal access token (classic) (no scopes required) or a fine-grained personal access token (only the automatic public repositories read access required) as suggested in the samples below, or use a conditional request. For more information, see <a href="/en/rest/guides/getting-started-with-the-rest-api#conditional-requests">Getting started with the REST API</a>.</p>
</div>
<div>
<p>
The signature was generated using the raw message body. So it's important you also use the raw message body for signature validation, instead of parsing and stringifying the JSON, to avoid rearranging the message or changing spacing.</p>
</div>
<p><strong>Sample HTTP POST sent to verify endpoint</strong></p>
<pre><code><span>POST</span> <span>/</span> <span>HTTP/2</span>
<span>Host</span><span>: </span>HOST
<span>Accept</span><span>: </span>*/*
<span>Content-Length</span><span>: </span>104
<span>Content-Type</span><span>: </span>application/json
<span>Github-Public-Key-Identifier</span><span>: </span>bcb53661c06b4728e59d897fb6165d5c9cda0fd9cdf9d09ead458168deb7518c
<span>Github-Public-Key-Signature</span><span>: </span>MEQCIQDaMKqrGnE27S0kgMrEK0eYBmyG0LeZismAEz/BgZyt7AIfXt9fErtRS4XaeSt/AO1RtBY66YcAdjxji410VQV4xg==

<span><span>[{<span>"source"</span>:<span>"commit"</span>,<span>"token"</span>:<span>"some_token"</span>,<span>"type"</span>:<span>"some_type"</span>,<span>"url"</span>:<span>"https://example.com/base-repo-url/"</span>}]</span>
</span></code></pre>
<p>The following code snippets demonstrate how you could perform signature validation.
The code examples assume you've set an environment variable called <code>GITHUB_PRODUCTION_TOKEN</code> with a generated <a href="https://github.com/settings/tokens">personal access token</a> to avoid hitting rate limits. The personal access token does not need any scopes/permissions.</p>
<p><strong>Validation sample in Go</strong></p>
<pre><code><span>package</span> main

<span>import</span> (
  <span>"crypto/ecdsa"</span>
  <span>"crypto/sha256"</span>
  <span>"crypto/x509"</span>
  <span>"encoding/asn1"</span>
  <span>"encoding/base64"</span>
  <span>"encoding/json"</span>
  <span>"encoding/pem"</span>
  <span>"errors"</span>
  <span>"fmt"</span>
  <span>"math/big"</span>
  <span>"net/http"</span>
  <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
  payload := <span>`[{"source":"commit","token":"some_token","type":"some_type","url":"https://example.com/base-repo-url/"}]`</span>

  kID := <span>"bcb53661c06b4728e59d897fb6165d5c9cda0fd9cdf9d09ead458168deb7518c"</span>

  kSig := <span>"MEQCIQDaMKqrGnE27S0kgMrEK0eYBmyG0LeZismAEz/BgZyt7AIfXt9fErtRS4XaeSt/AO1RtBY66YcAdjxji410VQV4xg=="</span>

  <span>// Fetch the list of GitHub Public Keys</span>
  req, err := http.NewRequest(<span>"GET"</span>, <span>"https://api.github.com/meta/public_keys/secret_scanning"</span>, <span>nil</span>)
  <span>if</span> err != <span>nil</span> {
    fmt.Printf(<span>"Error preparing request: %s\n"</span>, err)
    os.Exit(<span>1</span>)
  }

  <span>if</span> <span>len</span>(os.Getenv(<span>"GITHUB_PRODUCTION_TOKEN"</span>)) == <span>0</span> {
    fmt.Println(<span>"Need to define environment variable GITHUB_PRODUCTION_TOKEN"</span>)
    os.Exit(<span>1</span>)
  }

  req.Header.Add(<span>"Authorization"</span>, <span>"Bearer "</span>+os.Getenv(<span>"GITHUB_PRODUCTION_TOKEN"</span>))

  resp, err := http.DefaultClient.Do(req)
  <span>if</span> err != <span>nil</span> {
    fmt.Printf(<span>"Error requesting GitHub signing keys: %s\n"</span>, err)
    os.Exit(<span>2</span>)
  }

  decoder := json.NewDecoder(resp.Body)
  <span>var</span> keys GitHubSigningKeys
  <span>if</span> err := decoder.Decode(&amp;keys); err != <span>nil</span> {
    fmt.Printf(<span>"Error decoding GitHub signing key request: %s\n"</span>, err)
    os.Exit(<span>3</span>)
  }

  <span>// Find the Key used to sign our webhook</span>
  pubKey, err := <span><span>func</span><span>()</span></span> (<span>string</span>, <span>error</span>) {
    <span>for</span> _, v := <span>range</span> keys.PublicKeys {
      <span>if</span> v.KeyIdentifier == kID {
        <span>return</span> v.Key, <span>nil</span>

      }
    }
    <span>return</span> <span>""</span>, errors.New(<span>"specified key was not found in GitHub key list"</span>)
  }()

  <span>if</span> err != <span>nil</span> {
    fmt.Printf(<span>"Error finding GitHub signing key: %s\n"</span>, err)
    os.Exit(<span>4</span>)
  }

  <span>// Decode the Public Key</span>
  block, _ := pem.Decode([]<span>byte</span>(pubKey))
  <span>if</span> block == <span>nil</span> {
    fmt.Println(<span>"Error parsing PEM block with GitHub public key"</span>)
    os.Exit(<span>5</span>)
  }

  <span>// Create our ECDSA Public Key</span>
  key, err := x509.ParsePKIXPublicKey(block.Bytes)
  <span>if</span> err != <span>nil</span> {
    fmt.Printf(<span>"Error parsing DER encoded public key: %s\n"</span>, err)
    os.Exit(<span>6</span>)
  }

  <span>// Because of documentation, we know it's a *ecdsa.PublicKey</span>
  ecdsaKey, ok := key.(*ecdsa.PublicKey)
  <span>if</span> !ok {
    fmt.Println(<span>"GitHub key was not ECDSA, what are they doing?!"</span>)
    os.Exit(<span>7</span>)
  }

  <span>// Parse the Webhook Signature</span>
  parsedSig := asn1Signature{}
  asnSig, err := base64.StdEncoding.DecodeString(kSig)
  <span>if</span> err != <span>nil</span> {
    fmt.Printf(<span>"unable to base64 decode signature: %s\n"</span>, err)
    os.Exit(<span>8</span>)
  }
  rest, err := asn1.Unmarshal(asnSig, &amp;parsedSig)
  <span>if</span> err != <span>nil</span> || <span>len</span>(rest) != <span>0</span> {
    fmt.Printf(<span>"Error unmarshalling asn.1 signature: %s\n"</span>, err)
    os.Exit(<span>9</span>)
  }

  <span>// Verify the SHA256 encoded payload against the signature with GitHub's Key</span>
  digest := sha256.Sum256([]<span>byte</span>(payload))
  keyOk := ecdsa.Verify(ecdsaKey, digest[:], parsedSig.R, parsedSig.S)

  <span>if</span> keyOk {
    fmt.Println(<span>"THE PAYLOAD IS GOOD!!"</span>)
  } <span>else</span> {
    fmt.Println(<span>"the payload is invalid :("</span>)
    os.Exit(<span>10</span>)
  }
}

<span>type</span> GitHubSigningKeys <span>struct</span> {
  PublicKeys []<span>struct</span> {
    KeyIdentifier <span>string</span> <span>`json:"key_identifier"`</span>
    Key           <span>string</span> <span>`json:"key"`</span>
    IsCurrent     <span>bool</span>   <span>`json:"is_current"`</span>
  } <span>`json:"public_keys"`</span>
}

<span>// asn1Signature is a struct for ASN.1 serializing/parsing signatures.</span>
<span>type</span> asn1Signature <span>struct</span> {
  R *big.Int
  S *big.Int
}
</code></pre>
<p><strong>Validation sample in Ruby</strong></p>
<pre><code><span>require</span> <span>'openssl'</span>
<span>require</span> <span>'net/http'</span>
<span>require</span> <span>'uri'</span>
<span>require</span> <span>'json'</span>
<span>require</span> <span>'base64'</span>

payload = <span>&lt;&lt;-EOL
[{"source":"commit","token":"some_token","type":"some_type","url":"https://example.com/base-repo-url/"}]
EOL</span>

payload = payload

signature = <span>"MEQCIQDaMKqrGnE27S0kgMrEK0eYBmyG0LeZismAEz/BgZyt7AIfXt9fErtRS4XaeSt/AO1RtBY66YcAdjxji410VQV4xg=="</span>

key_id = <span>"bcb53661c06b4728e59d897fb6165d5c9cda0fd9cdf9d09ead458168deb7518c"</span>

url = <span>URI</span>.parse(<span>'https://api.github.com/meta/public_keys/secret_scanning'</span>)

<span>raise</span> <span>"Need to define GITHUB_PRODUCTION_TOKEN environment variable"</span> <span>unless</span> <span>ENV</span>[<span>'GITHUB_PRODUCTION_TOKEN'</span>]
request = <span>Net::HTTP::Get</span>.new(url.path)
request[<span>'Authorization'</span>] = <span>"Bearer <span>#{<span>ENV</span>[<span>'GITHUB_PRODUCTION_TOKEN'</span>]}</span>"</span>

http = <span>Net::HTTP</span>.new(url.host, url.port)
http.use_ssl = (url.scheme == <span>"https"</span>)

response = http.request(request)

parsed_response = <span>JSON</span>.parse(response.body)

current_key_object = parsed_response[<span>"public_keys"</span>].find { |<span>key</span>| key[<span>"key_identifier"</span>] == key_id }

current_key = current_key_object[<span>"key"</span>]

openssl_key = <span>OpenSSL::PKey::EC</span>.new(current_key)

puts openssl_key.verify(<span>Open</span>SSL::<span>Digest</span><span>:</span><span>:SHA256</span>.new, <span>Base64</span>.decode64(signature), payload.chomp)
</code></pre>
<p><strong>Validation sample in JavaScript</strong></p>
<pre><code><span>const</span> crypto = <span>require</span>(<span>"crypto"</span>);
<span>const</span> axios = <span>require</span>(<span>"axios"</span>);

<span>const</span> <span>GITHUB_KEYS_URI</span> = <span>"https://api.github.com/meta/public_keys/secret_scanning"</span>;

<span>/**
 * Verify a payload and signature against a public key
 * <span>@param</span> {<span>String</span>} payload the value to verify
 * <span>@param</span> {<span>String</span>} signature the expected value
 * <span>@param</span> {<span>String</span>} keyID the id of the key used to generated the signature
 * <span>@return</span> {<span>void</span>} throws if the signature is invalid
 */</span>
<span>const</span> <span>verify_signature</span> = <span>async</span> (<span>payload, signature, keyID</span>) =&gt; {
  <span>if</span> (<span>typeof</span> payload !== <span>"string"</span> || payload.<span>length</span> === <span>0</span>) {
    <span>throw</span> <span>new</span> <span>Error</span>(<span>"Invalid payload"</span>);
  }
  <span>if</span> (<span>typeof</span> signature !== <span>"string"</span> || signature.<span>length</span> === <span>0</span>) {
    <span>throw</span> <span>new</span> <span>Error</span>(<span>"Invalid signature"</span>);
  }
  <span>if</span> (<span>typeof</span> keyID !== <span>"string"</span> || keyID.<span>length</span> === <span>0</span>) {
    <span>throw</span> <span>new</span> <span>Error</span>(<span>"Invalid keyID"</span>);
  }

  <span>const</span> keys = (<span>await</span> axios.<span>get</span>(<span>GITHUB_KEYS_URI</span>)).<span>data</span>;
  <span>if</span> (!(keys?.<span>public_keys</span> <span>instanceof</span> <span>Array</span>) || keys.<span>length</span> === <span>0</span>) {
    <span>throw</span> <span>new</span> <span>Error</span>(<span>"No public keys found"</span>);
  }

  <span>const</span> publicKey = keys.<span>public_keys</span>.<span>find</span>(<span>(<span>k</span>) =&gt;</span> k.<span>key_identifier</span> === keyID) ?? <span>null</span>;
  <span>if</span> (publicKey === <span>null</span>) {
    <span>throw</span> <span>new</span> <span>Error</span>(<span>"No public key found matching key identifier"</span>);
  }

  <span>const</span> verify = crypto.<span>createVerify</span>(<span>"SHA256"</span>).<span>update</span>(payload);
  <span>if</span> (!verify.<span>verify</span>(publicKey.<span>key</span>, <span>Buffer</span>.<span>from</span>(signature, <span>"base64"</span>), <span>"base64"</span>)) {
    <span>throw</span> <span>new</span> <span>Error</span>(<span>"Signature does not match payload"</span>);
  }
};
</code></pre>
<h3><a href="#implement-secret-revocation-and-user-notification-in-your-secret-alert-service">Implement secret revocation and user notification in your secret alert service</a></h3>
<p>For secret scanning found publicly, you can enhance your secret alert service to revoke the exposed secrets and notify the affected users. How you implement this in your secret alert service is up to you, but we recommend considering any secrets that GitHub sends you messages about as public and compromised.</p>
<h3><a href="#provide-feedback-for-false-positives">Provide feedback for false positives</a></h3>
<p>We collect feedback on the validity of the detected individual secrets in partner responses. If you wish to take part, email us at <a href="mailto:secret-scanning@github.com"></a><a href="mailto:secret-scanning@github.com">secret-scanning@github.com</a>.</p>
<p>When we report secrets to you, we send a JSON array with each element containing the token, type identifier, and commit URL. When you send us feedback, you send us information about whether the detected token was a real or false credential. We accept feedback in the following formats.</p>
<p>You can send us the raw token:</p>
<pre><code><span>[</span>
  <span>{</span>
    <span>"token_raw"</span><span>:</span> <span>"The raw token"</span><span>,</span>
    <span>"token_type"</span><span>:</span> <span>"ACompany_API_token"</span><span>,</span>
    <span>"label"</span><span>:</span> <span>"true_positive"</span>
  <span>}</span>
<span>]</span>
</code></pre>
<p>You may also provide the token in hashed form after performing a one way cryptographic hash of the raw token using SHA-256:</p>
<pre><code><span>[</span>
  <span>{</span>
    <span>"token_hash"</span><span>:</span> <span>"The SHA-256 hashed form of the raw token"</span><span>,</span>
    <span>"token_type"</span><span>:</span> <span>"ACompany_API_token"</span><span>,</span>
    <span>"label"</span><span>:</span> <span>"false_positive"</span>
  <span>}</span>
<span>]</span>
</code></pre>
<p>A few important points:</p>
<ul>
<li>You should only send us either the raw form of the token ("token_raw"), or the hashed form ("token_hash"), but not both.</li>
<li>For the hashed form of the raw token, you can only use SHA-256 to hash the token, not any other hashing algorithm.</li>
<li>The label indicates whether the token is a true ("true_positive") or a false positive ("false_positive"). Only these two lowercased literal strings are allowed.</li>
</ul>
<div>
<p>
Our request timeout is set to be higher (that is, 30 seconds) for partners who provide data about false positives. If you require a timeout higher than 30 seconds, email us at <a href="mailto:secret-scanning@github.com"></a><a href="mailto:secret-scanning@github.com">secret-scanning@github.com</a>.</p>
</div>
</div></div></div>
</div>
</div></main>
</div></body></html>