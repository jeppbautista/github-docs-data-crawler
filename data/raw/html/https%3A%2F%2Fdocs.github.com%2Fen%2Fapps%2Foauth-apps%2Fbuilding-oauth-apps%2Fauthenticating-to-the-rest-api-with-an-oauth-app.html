<html><body><div>
<main><div>
<div><nav><ul>
<li>
<a title="Apps" href="/en/apps">Apps</a><span>/</span>
</li>
<li>
<a title="OAuth apps" href="/en/apps/oauth-apps">OAuth apps</a><span>/</span>
</li>
<li>
<a title="Building OAuth apps" href="/en/apps/oauth-apps/building-oauth-apps">Building OAuth apps</a><span>/</span>
</li>
<li><a title="Authenticate with an OAuth app" href="/en/apps/oauth-apps/building-oauth-apps/authenticating-to-the-rest-api-with-an-oauth-app">Authenticate with an OAuth app</a></li>
</ul></nav></div>
<div>
<div><div><h1>Authenticating to the REST API with an OAuth app</h1></div></div>
<div><div><p>Learn about the different ways to authenticate with some examples.</p></div></div>
<div>
<h2>In this article</h2>
<nav><ul>
<li><a href="#registering-your-app"><div><span>Registering your app</span></div></a></li>
<li><a href="#accepting-user-authorization"><div><span>Accepting user authorization</span></div></a></li>
<li><a href="#implementing-persistent-authentication"><div><span>Implementing "persistent" authentication</span></div></a></li>
</ul></nav>
</div>
<div><div><div>
<p>In this section, we're going to focus on the basics of authentication. Specifically,
we're going to create a Ruby server (using <a href="http://www.sinatrarb.com/">Sinatra</a>) that implements
the <a href="/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps">web flow</a> of an application in several different ways.</p>
<div>
<p>
You can download the complete source code for this project <a href="https://github.com/github/platform-samples/tree/master/api/">from the platform-samples repo</a>.</p>
</div>
<h2><a href="#registering-your-app">Registering your app</a></h2>
<p>First, you'll need to <a href="https://github.com/settings/applications/new">register your application</a>. Every
registered OAuth app is assigned a unique Client ID and Client Secret.
The client secret is used to get an access token for the signed-in user. You must
include the client secret in your native application, however web applications should not leak this value.</p>
<p>You can fill out every other piece of information however you like, except the
<strong>Authorization callback URL</strong>. This is the most important piece to securely setting
up your application. It's the callback URL that GitHub
returns the user to after successful authentication. Ownership of that URL is what ensures
that users sign into your app, instead of leaking tokens to an attacker.</p>
<p>Since we're running a regular Sinatra server, the location of the local instance
is set to <code>http://127.0.0.1:4567</code>. Let's fill in the callback URL as <code>http://127.0.0.1:4567/callback</code>.</p>
<h2><a href="#accepting-user-authorization">Accepting user authorization</a></h2>
<div>
<p>
<strong>Retired Notice:</strong> Authenticating to the GitHub API is no longer accessible using query parameters. Authenticating to the API should be done with <a href="/en/rest/overview/authenticating-to-the-rest-api#using-basic-authentication">HTTP basic authentication</a>. For more information, including scheduled brownouts, see the <a href="https://developer.github.com/changes/2020-02-10-deprecating-auth-through-query-param/">blog post</a>.</p>
</div>
<p>Now, let's start filling out our simple server. Create a file called <em>server.rb</em> and paste this into it:</p>
<pre><code><span>require</span> <span>'sinatra'</span>
<span>require</span> <span>'rest-client'</span>
<span>require</span> <span>'json'</span>

<span>CLIENT_ID</span> = <span>ENV</span>[<span>'GH_BASIC_CLIENT_ID'</span>]
<span>CLIENT_SECRET</span> = <span>ENV</span>[<span>'GH_BASIC_SECRET_ID'</span>]

get <span>'/'</span> <span>do</span>
  erb <span>:index</span>, <span>:locals</span> =&gt; {<span>:client_id</span> =&gt; <span>CLIENT_ID</span>}
<span>end</span>
</code></pre>
<p>Your client ID and client secret come from <a href="https://github.com/settings/developers">your application's configuration
page</a>. We recommend storing these values as
<a href="http://en.wikipedia.org/wiki/Environment_variable#Getting_and_setting_environment_variables">environment variables</a> for ease of replacement and use --
which is exactly what we've done here.</p>
<p>Next, in <em>views/index.erb</em>, paste this content:</p>
<pre><code><span>&lt;<span>html</span>&gt;</span>
  <span>&lt;<span>head</span>&gt;</span>
  <span>&lt;/<span>head</span>&gt;</span>
  <span>&lt;<span>body</span>&gt;</span>
    <span>&lt;<span>p</span>&gt;</span>
      Well, hello there!
    <span>&lt;/<span>p</span>&gt;</span>
    <span>&lt;<span>p</span>&gt;</span>
      We're going to now talk to the GitHub API. Ready?
      <span>&lt;<span>a</span> <span>href</span>=<span>"https://github.com/login/oauth/authorize?scope=user:email&amp;client_id=&lt;%= client_id %&gt;"</span>&gt;</span>Click here<span>&lt;/<span>a</span>&gt;</span> to begin!
    <span>&lt;/<span>p</span>&gt;</span>
    <span>&lt;<span>p</span>&gt;</span>
      If that link doesn't work, remember to provide your own <span>&lt;<span>a</span> <span>href</span>=<span>"/apps/building-oauth-apps/authorizing-oauth-apps/"</span>&gt;</span>Client ID<span>&lt;/<span>a</span>&gt;</span>!
    <span>&lt;/<span>p</span>&gt;</span>
  <span>&lt;/<span>body</span>&gt;</span>
<span>&lt;/<span>html</span>&gt;</span>
</code></pre>
<p>(If you're unfamiliar with how Sinatra works, we recommend <a href="https://github.com/sinatra/sinatra-book/blob/main/book/Introduction.markdown#hello-world-application">reading the Sinatra guide</a>.)</p>
<p>Also, notice that the URL uses the <code>scope</code> query parameter to define the
<a href="/en/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps">scopes</a> requested by the application. For our application, we're
requesting <code>user:email</code> scope for reading private email addresses.</p>
<p>Navigate your browser to <code>http://127.0.0.1:4567</code>. After clicking on the link, you should be taken to GitHub, and presented with an "Authorize application" dialog.</p>
<p>If you trust yourself, click <strong>Authorize App</strong>. Wuh-oh! Sinatra spits out a
<code>404</code> error. What gives?!</p>
<p>Well, remember when we specified a Callback URL to be <code>callback</code>? We didn't provide
a route for it, so GitHub doesn't know where to drop the user after they authorize
the app. Let's fix that now!</p>
<h3><a href="#providing-a-callback">Providing a callback</a></h3>
<p>In <em>server.rb</em>, add a route to specify what the callback should do:</p>
<pre><code>get <span>'/callback'</span> <span>do</span>
  <span># get temporary GitHub code...</span>
  session_code = request.env[<span>'rack.request.query_hash'</span>][<span>'code'</span>]

  <span># ... and POST it back to GitHub</span>
  result = <span>RestClient</span>.post(<span>'https://github.com/login/oauth/access_token'</span>,
                          {<span>:client_id</span> =&gt; <span>CLIENT_ID</span>,
                           <span>:client_secret</span> =&gt; <span>CLIENT_SECRET</span>,
                           <span>:code</span> =&gt; session_code},
                           <span>:accept</span> =&gt; <span>:json</span>)

  <span># extract the token and granted scopes</span>
  access_token = <span>JSON</span>.parse(result)[<span>'access_token'</span>]
<span>end</span>
</code></pre>
<p>After a successful app authentication, GitHub provides a temporary <code>code</code> value.
You'll need to <code>POST</code> this code back to GitHub with your client secret
in exchange for an <code>access_token</code>.
To simplify our GET and POST HTTP requests, we're using the <a href="https://github.com/archiloque/rest-client">rest-client</a>.
Note that you'll probably never access the API through REST. For a more serious
application, you should probably use <a href="/en/rest/overview/libraries">a library written in the language of your choice</a>.</p>
<h3><a href="#checking-granted-scopes">Checking granted scopes</a></h3>
<p>Users can edit the scopes you requested by directly changing the URL. This can grant your application less access than you originally asked for. Before making any requests with the token, check the scopes that were granted for the token by the user. For more information about requested and granted scopes, see <a href="/en/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps#requested-scopes-and-granted-scopes">Scopes for OAuth apps</a>.</p>
<p>The scopes that were granted are returned as a part of the response from
exchanging a token.</p>
<pre><code>get <span>'/callback'</span> <span>do</span>
  <span># ...</span>
  <span># Get the access_token using the code sample above</span>
  <span># ...</span>

  <span># check if we were granted user:email scope</span>
  scopes = <span>JSON</span>.parse(result)[<span>'scope'</span>].split(<span>','</span>)
  has_user_email_scope = scopes.<span>include</span>? <span>'user:email'</span> |<span>include</span>? <span>'user'</span>
<span>end</span>
</code></pre>
<p>In our application, we're using <code>scopes.include?</code> to check if we were granted
the <code>user:email</code> scope needed for fetching the authenticated user's private
email addresses. Had the application asked for other scopes, we would have
checked for those as well.</p>
<p>Also, since there's a hierarchical relationship between scopes, you should
check if you were granted any higher levels of the required scope. For example,
if the application had asked for <code>user</code> scope, it won't have been granted explicitly the
<code>user:email</code> scope. In that case, it would receive a token with the <code>user</code> scope, which
would work for requesting the user's email address, even though it doesn't explicitly include
<code>user:email</code> on the token. Checking for both <code>user</code> and <code>user:email</code> ensures that you
check for both scenarios.</p>
<p>Checking for scopes only before making requests is not enough since it's possible
that users will change the scopes in between your check and the actual request.
In case that happens, API calls you expected to succeed might fail with a <code>404</code>
or <code>401</code> status, or return a different subset of information.</p>
<p>To help you gracefully handle these situations, all API responses for requests
made with valid OAuth app tokens also contain an <a href="/en/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps"><code>X-OAuth-Scopes</code> header</a>.
This header contains the list of scopes of the token that was used to make the
request. In addition to that, the REST API provides an endpoint to
<a href="/en/rest/apps/oauth-applications#check-a-token">check a token for validity</a>.
Use this information to detect changes in token scopes, and inform your users of
changes in available application functionality.</p>
<h3><a href="#making-authenticated-requests">Making authenticated requests</a></h3>
<p>At last, with this access token, you'll be able to make authenticated requests as
the logged in user:</p>
<pre><code><span># fetch user information</span>
auth_result = <span>JSON</span>.parse(<span>RestClient</span>.get(<span>'https://api.github.com/user'</span>,
                                        {<span>:params</span> =&gt; {<span>:access_token</span> =&gt; access_token}}))

<span># if the user authorized it, fetch private emails</span>
<span>if</span> has_user_email_scope
  auth_result[<span>'private_emails'</span>] =
    <span>JSON</span>.parse(<span>RestClient</span>.get(<span>'https://api.github.com/user/emails'</span>,
                              {<span>:params</span> =&gt; {<span>:access_token</span> =&gt; access_token}}))
<span>end</span>

erb <span>:basic</span>, <span>:locals</span> =&gt; auth_result
</code></pre>
<p>We can do whatever we want with our results. In this case, we'll just dump them straight into <em>basic.erb</em>:</p>
<pre><code><span>&lt;<span>p</span>&gt;</span>Hello, &lt;%= login %&gt;!<span>&lt;/<span>p</span>&gt;</span>
<span>&lt;<span>p</span>&gt;</span>
  &lt;% if !email.nil? &amp;&amp; !email.empty? %&gt; It looks like your public email address is &lt;%= email %&gt;.
  &lt;% else %&gt; It looks like you don't have a public email. That's cool.
  &lt;% end %&gt;
<span>&lt;/<span>p</span>&gt;</span>
<span>&lt;<span>p</span>&gt;</span>
  &lt;% if defined? private_emails %&gt;
  With your permission, we were also able to dig up your private email addresses:
  &lt;%= private_emails.map{ |private_email_address| private_email_address["email"] }.join(', ') %&gt;
  &lt;% else %&gt;
  Also, you're a bit secretive about your private email addresses.
  &lt;% end %&gt;
<span>&lt;/<span>p</span>&gt;</span>
</code></pre>
<h2><a href="#implementing-persistent-authentication">Implementing "persistent" authentication</a></h2>
<p>It'd be a pretty bad model if we required users to log into the app every single
time they needed to access the web page. For example, try navigating directly to
<code>http://127.0.0.1:4567/basic</code>. You'll get an error.</p>
<p>What if we could circumvent the entire
"click here" process, and just <em>remember</em> that, as long as the user's logged into
GitHub, they should be able to access this application? Hold on to your hat,
because <em>that's exactly what we're going to do</em>.</p>
<p>Our little server above is rather simple. In order to wedge in some intelligent
authentication, we're going to switch over to using sessions for storing tokens.
This will make authentication transparent to the user.</p>
<p>Also, since we're persisting scopes within the session, we'll need to
handle cases when the user updates the scopes after we checked them, or revokes
the token. To do that, we'll use a <code>rescue</code> block and check that the first API
call succeeded, which verifies that the token is still valid. After that, we'll
check the <code>X-OAuth-Scopes</code> response header to verify that the user hasn't revoked
the <code>user:email</code> scope.</p>
<p>Create a file called <em>advanced_server.rb</em>, and paste these lines into it:</p>
<pre><code><span>require</span> <span>'sinatra'</span>
<span>require</span> <span>'rest_client'</span>
<span>require</span> <span>'json'</span>

<span># Don't use hard-coded values in your app</span>
<span># Instead, set and test environment variables, like below</span>
<span># if ENV['GITHUB_CLIENT_ID'] &amp;&amp; ENV['GITHUB_CLIENT_SECRET']</span>
<span>#  CLIENT_ID        = ENV['GITHUB_CLIENT_ID']</span>
<span>#  CLIENT_SECRET    = ENV['GITHUB_CLIENT_SECRET']</span>
<span># end</span>

<span>CLIENT_ID</span> = <span>ENV</span>[<span>'GH_BASIC_CLIENT_ID'</span>]
<span>CLIENT_SECRET</span> = <span>ENV</span>[<span>'GH_BASIC_SECRET_ID'</span>]

use <span>Rack</span><span>:</span><span>:Session</span><span>:</span><span>:Pool</span>, <span>:cookie_only</span> =&gt; <span>false</span>

<span>def</span> <span>authenticated?</span>
  session[<span>:access_token</span>]
<span>end</span>

<span>def</span> <span>authenticate!</span>
  erb <span>:index</span>, <span>:locals</span> =&gt; {<span>:client_id</span> =&gt; <span>CLIENT_ID</span>}
<span>end</span>

get <span>'/'</span> <span>do</span>
  <span>if</span> !authenticated?
    authenticate!
  <span>else</span>
    access_token = session[<span>:access_token</span>]
    scopes = []

    <span>begin</span>
      auth_result = <span>RestClient</span>.get(<span>'https://api.github.com/user'</span>,
                                   {<span>:params</span> =&gt; {<span>:access_token</span> =&gt; access_token},
                                    <span>:accept</span> =&gt; <span>:json</span>})
    <span>rescue</span> =&gt; e
      <span># request didn't succeed because the token was revoked so we</span>
      <span># invalidate the token stored in the session and render the</span>
      <span># index page so that the user can start the OAuth flow again</span>

      session[<span>:access_token</span>] = <span>nil</span>
      <span>return</span> authenticate!
    <span>end</span>

    <span># the request succeeded, so we check the list of current scopes</span>
    <span>if</span> auth_result.headers.<span>include</span>? <span>:x_oauth_scopes</span>
      scopes = auth_result.headers[<span>:x_oauth_scopes</span>].split(<span>', '</span>)
    <span>end</span>

    auth_result = <span>JSON</span>.parse(auth_result)

    <span>if</span> scopes.<span>include</span>? <span>'user:email'</span>
      auth_result[<span>'private_emails'</span>] =
        <span>JSON</span>.parse(<span>RestClient</span>.get(<span>'https://api.github.com/user/emails'</span>,
                       {<span>:params</span> =&gt; {<span>:access_token</span> =&gt; access_token},
                        <span>:accept</span> =&gt; <span>:json</span>}))
    <span>end</span>

    erb <span>:advanced</span>, <span>:locals</span> =&gt; auth_result
  <span>end</span>
<span>end</span>

get <span>'/callback'</span> <span>do</span>
  session_code = request.env[<span>'rack.request.query_hash'</span>][<span>'code'</span>]

  result = <span>RestClient</span>.post(<span>'https://github.com/login/oauth/access_token'</span>,
                          {<span>:client_id</span> =&gt; <span>CLIENT_ID</span>,
                           <span>:client_secret</span> =&gt; <span>CLIENT_SECRET</span>,
                           <span>:code</span> =&gt; session_code},
                           <span>:accept</span> =&gt; <span>:json</span>)

  session[<span>:access_token</span>] = <span>JSON</span>.parse(result)[<span>'access_token'</span>]

  redirect <span>'/'</span>
<span>end</span>
</code></pre>
<p>Much of the code should look familiar. For example, we're still using <code>RestClient.get</code>
to call out to the GitHub API, and we're still passing our results to be rendered
in an ERB template (this time, it's called <code>advanced.erb</code>).</p>
<p>Also, we now have the <code>authenticated?</code> method which checks if the user is already
authenticated. If not, the <code>authenticate!</code> method is called, which performs the
OAuth flow and updates the session with the granted token and scopes.</p>
<p>Next, create a file in <em>views</em> called <em>advanced.erb</em>, and paste this markup into it:</p>
<pre><code><span>&lt;<span>html</span>&gt;</span>
  <span>&lt;<span>head</span>&gt;</span>
  <span>&lt;/<span>head</span>&gt;</span>
  <span>&lt;<span>body</span>&gt;</span>
    <span>&lt;<span>p</span>&gt;</span>Well, well, well, &lt;%= login %&gt;!<span>&lt;/<span>p</span>&gt;</span>
    <span>&lt;<span>p</span>&gt;</span>
      &lt;% if !email.empty? %&gt; It looks like your public email address is &lt;%= email %&gt;.
      &lt;% else %&gt; It looks like you don't have a public email. That's cool.
      &lt;% end %&gt;
    <span>&lt;/<span>p</span>&gt;</span>
    <span>&lt;<span>p</span>&gt;</span>
      &lt;% if defined? private_emails %&gt;
      With your permission, we were also able to dig up your private email addresses:
      &lt;%= private_emails.map{ |private_email_address| private_email_address["email"] }.join(', ') %&gt;
      &lt;% else %&gt;
      Also, you're a bit secretive about your private email addresses.
      &lt;% end %&gt;
    <span>&lt;/<span>p</span>&gt;</span>
  <span>&lt;/<span>body</span>&gt;</span>
<span>&lt;/<span>html</span>&gt;</span>
</code></pre>
<p>From the command line, call <code>ruby advanced_server.rb</code>, which starts up your
server on port <code>4567</code> -- the same port we used when we had a simple Sinatra app.
When you navigate to <code>http://127.0.0.1:4567</code>, the app calls <code>authenticate!</code>
which redirects you to <code>/callback</code>. <code>/callback</code> then sends us back to <code>/</code>,
and since we've been authenticated, renders <em>advanced.erb</em>.</p>
<p>We could completely simplify this roundtrip routing by simply changing our callback
URL in GitHub to <code>/</code>. But, since both <em>server.rb</em> and <em>advanced.rb</em> are relying on
the same callback URL, we've got to do a little bit of wonkiness to make it work.</p>
<p>Also, if we had never authorized this application to access our GitHub data,
we would've seen the same confirmation dialog from earlier pop-up and warn us.</p>
</div></div></div>
</div>
</div></main>
</div></body></html>