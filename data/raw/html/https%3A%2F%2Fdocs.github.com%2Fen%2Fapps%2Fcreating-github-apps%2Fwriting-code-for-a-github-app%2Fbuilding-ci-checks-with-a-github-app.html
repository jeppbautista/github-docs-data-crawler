<html><body><div>
<main><div>
<div><nav><ul>
<li>
<a title="Apps" href="/en/apps">Apps</a><span>/</span>
</li>
<li>
<a title="Creating GitHub Apps" href="/en/apps/creating-github-apps">Creating GitHub Apps</a><span>/</span>
</li>
<li>
<a title="Writing code for a GitHub App" href="/en/apps/creating-github-apps/writing-code-for-a-github-app">Writing code for a GitHub App</a><span>/</span>
</li>
<li><a title="Build CI checks" href="/en/apps/creating-github-apps/writing-code-for-a-github-app/building-ci-checks-with-a-github-app">Build CI checks</a></li>
</ul></nav></div>
<div>
<div><div><h1>Building CI checks with a GitHub App</h1></div></div>
<div><div><p>Build a continuous integration server to run tests using a GitHub App and checks.</p></div></div>
<div>
<h2>In this article</h2>
<nav><ul>
<li><a href="#introduction"><div><span>Introduction</span></div></a></li>
<li><a href="#prerequisites"><div><span>Prerequisites</span></div></a></li>
<li><a href="#setup"><div><span>Setup</span></div></a></li>
<li><a href="#add-code-for-your-github-app"><div><span>Add code for your GitHub App</span></div></a></li>
<li><a href="#start-the-server"><div><span>Start the server</span></div></a></li>
<li><a href="#test-that-the-server-is-listening-to-your-app"><div><span>Test that the server is listening to your app</span></div></a></li>
<li><a href="#part-1-creating-the-checks-api-interface"><div><span>Part 1. Creating the Checks API interface</span></div></a></li>
<li><a href="#step-11-add-event-handling"><div><span>Step 1.1. Add event handling</span></div></a></li>
<li><a href="#step-12-create-a-check-run"><div><span>Step 1.2. Create a check run</span></div></a></li>
<li><a href="#step-13-update-a-check-run"><div><span>Step 1.3. Update a check run</span></div></a></li>
<li><a href="#part-2-creating-a-ci-test"><div><span>Part 2. Creating a CI test</span></div></a></li>
<li><a href="#step-21-add-a-ruby-file"><div><span>Step 2.1. Add a Ruby file</span></div></a></li>
<li><a href="#step-22-allow-rubocop-to-clone-the-test-repository"><div><span>Step 2.2. Allow RuboCop to clone the test repository</span></div></a></li>
<li><a href="#step-23-run-rubocop"><div><span>Step 2.3. Run RuboCop</span></div></a></li>
<li><a href="#step-24-collect-rubocop-errors"><div><span>Step 2.4. Collect RuboCop errors</span></div></a></li>
<li><a href="#step-25-update-the-check-run-with-ci-test-results"><div><span>Step 2.5. Update the check run with CI test results</span></div></a></li>
<li><a href="#step-26-automatically-fix-rubocop-errors"><div><span>Step 2.6. Automatically fix RuboCop errors</span></div></a></li>
<li><a href="#full-code-example"><div><span>Full code example</span></div></a></li>
<li><a href="#next-steps"><div><span>Next steps</span></div></a></li>
</ul></nav>
</div>
<div><div><div>
<h2><a href="#introduction">Introduction</a></h2>
<p>This tutorial demonstrates how to build a continuous integration (CI) server that runs tests on new code that's pushed to a repository. The tutorial shows how to build and configure a GitHub App to act as a server that receives and responds to <code>check_run</code> and <code>check_suite</code> webhook events using GitHub's REST API.</p>
<p>In this tutorial, you will use your computer or codespace as a server while you develop your app. Once the app is ready for production use, you should deploy your app to a dedicated server.</p>
<p>This tutorial uses Ruby, but you can use any programming language that you can run on your server.</p>
<p>This tutorial is broken into two parts:</p>
<ul>
<li>In part one, you'll learn how to set up the framework for a CI server using GitHub's REST API, create new check runs for CI tests when a repository receives newly pushed commits, and re-run check runs when a user requests that action on GitHub.</li>
<li>In part two, you'll add functionality to your CI test, by adding a linter test to your CI server. You'll also create annotations that are displayed in the <strong>Checks</strong> and <strong>Files Changed</strong> tab of a pull request, and automatically fix linter recommendations by exposing a "Fix this" button in the <strong>Checks</strong> tab of the pull request.</li>
</ul>
<h3><a href="#about-continuous-integration-ci">About continuous integration (CI)</a></h3>
<p>CI is a software practice that requires frequently committing code to a shared repository. Committing code more often raises errors sooner and reduces the amount of code a developer needs to debug when finding the source of an error. Frequent code updates also make it easier to merge changes from different members of a software development team. This is great for developers, who can spend more time writing code and less time debugging errors or resolving merge conflicts.</p>
<p>A CI server hosts code that runs CI tests such as code linters (which check style formatting), security checks, code coverage, and other checks against new code commits in a repository. CI servers can even build and deploy code to staging or production servers. For examples of the types of CI tests you can create with a GitHub App, see the <a href="https://github.com/marketplace/category/continuous-integration">continuous integration apps</a> that are available in GitHub Marketplace.</p>
<h3><a href="#about-checks">About checks</a></h3>
<p>GitHub's REST API allows you to set up CI tests (checks) that are automatically run against each code commit in a repository. The API reports detailed information about each check in the pull request's <strong>Checks</strong> tab on GitHub. You can use checks in a repository to determine when a code commit introduces errors.</p>
<p>Checks include check runs, check suites, and commit statuses.</p>
<ul>
<li>A <em>check run</em> is an individual CI test that runs on a commit.</li>
<li>A <em>check suite</em> is a group of check runs.</li>
<li>A <em>commit status</em> marks the state of a commit, for example <code>error</code>, <code>failure</code>, <code>pending</code>, or <code>success</code>, and is visible in a pull request on GitHub. Both check suites and check runs contain commit statuses.</li>
</ul>
<p>GitHub automatically creates <code>check_suite</code> events for new code commits in a repository using the default flow, although you can change the default settings. For more information, see <a href="/en/rest/checks/suites#update-repository-preferences-for-check-suites">REST API endpoints for check suites</a>. Here's how the default flow works:</p>
<ol>
<li>When someone pushes code to the repository, GitHub automatically sends the <code>check_suite</code> event with an action of <code>requested</code> to all GitHub Apps installed on the repository that have the <code>checks:write</code> permission. This event lets the apps know that code was pushed to the repository, and that GitHub has automatically created a new check suite.</li>
<li>When your app receives this event, it can add check runs to that suite.</li>
<li>Your check runs can include annotations that are displayed on specific lines of code. Annotations are visible in the <strong>Checks</strong> tab. When you create an annotation for a file that is part of the pull request, the annotations are also shown in the <strong>Files changed</strong> tab. For more information, see the <code>annotations</code> object in <a href="/en/rest/checks/runs#create-a-check-run">REST API endpoints for check runs</a>.</li>
</ol>
<p>For more information about checks, see <a href="/en/rest/checks">REST API endpoints for checks</a> and <a href="/en/rest/guides/using-the-rest-api-to-interact-with-checks">Using the REST API to interact with checks</a>.</p>
<h2><a href="#prerequisites">Prerequisites</a></h2>
<p>This tutorial assumes you have a basic understanding of the <a href="https://www.ruby-lang.org/en/">Ruby programming language</a>.</p>
<p>Before you get started, you may want to familiarize yourself with the following concepts:</p>
<ul>
<li><a href="/en/apps">GitHub Apps</a></li>
<li><a href="/en/webhooks-and-events/webhooks/about-webhooks">Webhooks</a></li>
<li><a href="/en/rest/checks">REST API checks endpoints</a></li>
</ul>
<p>Checks are also available to use with the GraphQL API, but this tutorial focuses on the REST API. For more information about the GraphQL objects, see <a href="/en/graphql/reference/objects#checksuite">Check Suite</a> and <a href="/en/graphql/reference/objects#checkrun">Check Run</a> in the GraphQL documentation.</p>
<h2><a href="#setup">Setup</a></h2>
<p>The following sections will lead you through setting up the following components:</p>
<ul>
<li>A repository to store the code for your app.</li>
<li>A way to receive webhooks locally.</li>
<li>A GitHub App that is subscribed to "Check suite" and "Check run" webhook events, has write permission for checks, and uses a webhook URL that you can receive locally.</li>
</ul>
<h3><a href="#create-a-repository-to-store-code-for-your-github-app">Create a repository to store code for your GitHub App</a></h3>
<ol>
<li>
<p>Create a repository to store the code for your app. For more information, see <a href="/en/repositories/creating-and-managing-repositories/creating-a-new-repository">Creating a new repository</a>.</p>
</li>
<li>
<p>Clone your repository from the previous step. For more information, see <a href="/en/repositories/creating-and-managing-repositories/cloning-a-repository">Cloning a repository</a>. You may use a local clone or GitHub Codespaces.</p>
</li>
<li>
<p>In a terminal, navigate to the directory where your clone is stored.</p>
</li>
<li>
<p>Create a Ruby file named <code>server.rb</code>. This file will contain all the code for your app. You will add content to this file later.</p>
</li>
<li>
<p>If the directory doesn't already include a <code>.gitignore</code> file, add a <code>.gitignore</code> file. You will add content to this file later. For more information about <code>.gitignore</code> files, see <a href="/en/get-started/git-basics/ignoring-files">Ignoring files</a>.</p>
</li>
<li>
<p>Create a file named <code>Gemfile</code>. This file will describe the gem dependencies that your Ruby code needs. Add the following contents to your <code>Gemfile</code>:</p>
<div>
<header><span>Ruby</span><pre>source 'http://rubygems.org'

gem 'sinatra', '~&gt; 2.0'
gem 'jwt', '~&gt; 2.1'
gem 'octokit', '~&gt; 4.0'
gem 'puma'
gem 'rubocop'
gem 'dotenv'
gem 'git'
</pre></header><pre><code>source <span>'http://rubygems.org'</span>

gem <span>'sinatra'</span>, <span>'~&gt; 2.0'</span>
gem <span>'jwt'</span>, <span>'~&gt; 2.1'</span>
gem <span>'octokit'</span>, <span>'~&gt; 4.0'</span>
gem <span>'puma'</span>
gem <span>'rubocop'</span>
gem <span>'dotenv'</span>
gem <span>'git'</span>
</code></pre>
</div>
</li>
<li>
<p>Create a file named <code>config.ru</code>. This file will configure your Sinatra server to run. Add the following contents to your <code>config.ru</code> file:</p>
<div>
<header><span>Ruby</span><pre>require './server'
run GHAapp
</pre></header><pre><code><span>require</span> <span>'./server'</span>
run <span>GHAapp</span>
</code></pre>
</div>
</li>
</ol>
<h3><a href="#get-a-webhook-proxy-url">Get a webhook proxy URL</a></h3>
<p>In order to develop your app locally, you can use a webhook proxy URL to forward webhook events from GitHub to your computer or codespace. This tutorial uses Smee.io to provide a webhook proxy URL and forward events.</p>
<ol>
<li>
<p>In a terminal, run the following command to install the Smee client:</p>
<div>
<header><span>Shell</span><pre>npm install --global smee-client
</pre></header><pre><code>npm install --global smee-client
</code></pre>
</div>
</li>
<li>
<p>In your browser, navigate to <a href="https://smee.io/">https://smee.io/</a>.</p>
</li>
<li>
<p>Click <strong>Start a new channel</strong>.</p>
</li>
<li>
<p>Copy the full URL under "Webhook Proxy URL".</p>
</li>
<li>
<p>In the terminal, run the following command to start the Smee client. Replace <code>YOUR_DOMAIN</code> with the Webhook Proxy URL you copied in the previous step.</p>
<div>
<header><span>Shell</span><pre>smee --url YOUR_DOMAIN --path /event_handler --port 3000
</pre></header><pre><code>smee --url YOUR_DOMAIN --path /event_handler --port 3000
</code></pre>
</div>
<p>You should see output like the following:</p>
<pre><code>Forwarding https://smee.io/YOUR_DOMAIN to http://127.0.0.1:3000/event_handler
Connected https://smee.io/YOUR_DOMAIN
</code></pre>
</li>
</ol>
<p>The <code>smee --url https://smee.io/YOUR_DOMAIN</code> command tells Smee to forward all webhook events received by the Smee channel to the Smee client running on your computer. The <code>--path /event_handler</code> option forwards events to the <code>/event_handler</code> route. The <code>--port 3000</code> option specifies port 3000, which is the port you will tell your server to listen to, when you add more code later in the tutorial. Using Smee, your machine does not need to be open to the public internet to receive webhooks from GitHub. You can also open that Smee URL in your browser to inspect webhook payloads as they come in.</p>
<p>We recommend leaving this terminal window open and keeping Smee connected while you complete the rest of the steps in this guide. Although you can disconnect and reconnect the Smee client without losing your unique domain, you may find it easier to leave it connected and do other command-line tasks in a different terminal window.</p>
<h3><a href="#register-a-github-app">Register a GitHub App</a></h3>
<p>For this tutorial, you must register a GitHub App that:</p>
<ul>
<li>Has webhooks active</li>
<li>Uses a webhook URL that you can receive locally</li>
<li>Has the "Checks" repository permission</li>
<li>Subscribes to the "Check suite" and "Check run" webhook events</li>
</ul>
<p>The following steps will guide you through configuring a GitHub App with these settings. For more information about GitHub App settings, see <a href="/en/apps/creating-github-apps/creating-github-apps/creating-a-github-app">Registering a GitHub App</a>.</p>
<ol>
<li>
<p>In the upper-right corner of any page on GitHub, click your profile photo.</p>
</li>
<li>
<p>Navigate to your account settings.</p>
<ul>
<li>For an app owned by a personal account, click <strong>Settings</strong>.</li>
<li>For an app owned by an organization:
<ol>
<li>Click <strong>Your organizations</strong>.</li>
<li>To the right of the organization, click <strong>Settings</strong>.</li>
</ol>
</li>
</ul>
</li>
<li>
<p>In the left sidebar, click </p>
</li>
<li>
<p>In the left sidebar, click <strong>GitHub Apps</strong>.</p>
</li>
<li>
<p>Click <strong>New GitHub App</strong>.</p>
</li>
<li>
<p>Under "GitHub App name", enter a name for your app. For example, <code>USERNAME-ci-test-app</code> where <code>USERNAME</code> is your GitHub username.</p>
</li>
<li>
<p>Under "Homepage URL", enter a URL for your app. For example, you can use the URL of the repository that you created to store the code for your app.</p>
</li>
<li>
<p>Skip the "Identifying and authorizing users" and "Post installation" sections for this tutorial.</p>
</li>
<li>
<p>Make sure that <strong>Active</strong> is selected under "Webhooks".</p>
</li>
<li>
<p>Under "Webhook URL", enter your webhook proxy URL from earlier. For more information, see <a href="#get-a-webhook-proxy-url">Get a webhook proxy URL</a>.</p>
</li>
<li>
<p>Under "Webhook secret", enter a random string. This secret is used to verify that webhooks are sent by GitHub. Save this string; you will use it later.</p>
</li>
<li>
<p>Under "Repository permissions", next to "Checks", select <strong>Read &amp; write</strong>.</p>
</li>
<li>
<p>Under "Subscribe to events", select <strong>Check suite</strong> and <strong>Check run</strong>.</p>
</li>
<li>
<p>Under "Where can this GitHub App be installed?", select <strong>Only on this account</strong>. You can change this later if you want to publish your app.</p>
</li>
<li>
<p>Click <strong>Create GitHub App</strong>.</p>
</li>
</ol>
<h3><a href="#store-your-apps-identifying-information-and-credentials">Store your app's identifying information and credentials</a></h3>
<p>This tutorial will show you how to store your app's credentials and identifying information as environment variables in a <code>.env</code> file. When you deploy your app, you should change how you store the credentials. For more information, see <a href="#deploy-your-app">Deploy your app</a>.</p>
<p>Make sure that you are on a secure machine before performing these steps, since you will store your credentials locally.</p>
<ol>
<li>
<p>In your terminal, navigate to the directory where your clone is stored.</p>
</li>
<li>
<p>Create a file called <code>.env</code> at the top level of this directory.</p>
</li>
<li>
<p>Add <code>.env</code> to your <code>.gitignore</code> file. This will prevent you from accidentally committing your app's credentials.</p>
</li>
<li>
<p>Add the following contents to your <code>.env</code> file. You will update the values in a later step.</p>
<div>
<header><span>Shell</span><pre>GITHUB_APP_IDENTIFIER="YOUR_APP_ID"
GITHUB_WEBHOOK_SECRET="YOUR_WEBHOOK_SECRET"
GITHUB_PRIVATE_KEY="YOUR_PRIVATE_KEY"
</pre></header><pre><code>GITHUB_APP_IDENTIFIER="YOUR_APP_ID"
GITHUB_WEBHOOK_SECRET="YOUR_WEBHOOK_SECRET"
GITHUB_PRIVATE_KEY="YOUR_PRIVATE_KEY"
</code></pre>
</div>
</li>
<li>
<p>Navigate to the settings page for your app:</p>
<ol>
<li>
<p>In the upper-right corner of any page on GitHub, click your profile photo.</p>
</li>
<li>
<p>Navigate to your account settings.</p>
<ul>
<li>For an app owned by a personal account, click <strong>Settings</strong>.</li>
<li>For an app owned by an organization:
<ol>
<li>Click <strong>Your organizations</strong>.</li>
<li>To the right of the organization, click <strong>Settings</strong>.</li>
</ol>
</li>
</ul>
</li>
<li>
<p>In the left sidebar, click </p>
</li>
<li>
<p>In the left sidebar, click <strong>GitHub Apps</strong>.</p>
</li>
<li>
<p>Next to your app's name, click <strong>Edit</strong>.</p>
</li>
</ol>
</li>
<li>
<p>On your app's settings page, next to "App ID", find the app ID for your app.</p>
</li>
<li>
<p>In your <code>.env</code> file, replace <code>YOUR_APP_ID</code> with the app ID of your app.</p>
</li>
<li>
<p>In your <code>.env</code> file, replace <code>YOUR_WEBHOOK_SECRET</code> with the webhook secret for your app. If you have forgotten your webhook secret, under "Webhook secret (optional)", click <strong>Change secret</strong>. Enter a new secret, then click <strong>Save changes</strong>.</p>
</li>
<li>
<p>On your app's settings page, under "Private keys", click <strong>Generate a private key</strong>. You will see a private key <code>.pem</code> file downloaded to your computer.</p>
</li>
<li>
<p>Open the <code>.pem</code> file with a text editor, or use the following command on the command line to display the contents of the file: <code>cat PATH/TO/YOUR/private-key.pem</code>.</p>
</li>
<li>
<p>Copy and paste the entire contents of the file into your <code>.env</code> file as the value of <code>GITHUB_PRIVATE_KEY</code>, and add double quotes around the entire value.</p>
<p>Here is an example .env file:</p>
<pre><code>GITHUB_APP_IDENTIFIER=12345
GITHUB_WEBHOOK_SECRET=your webhook secret
GITHUB_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----
...
HkVN9...
...
-----END RSA PRIVATE KEY-----"
</code></pre>
</li>
</ol>
<h2><a href="#add-code-for-your-github-app">Add code for your GitHub App</a></h2>
<p>This section will show you how to add some basic template code for your GitHub App, and it will explain what the code does. Later in the tutorial, you will learn how to modify and add to this code, to build out your app's functionality.</p>
<p>Add the following template code to your <code>server.rb</code> file:</p>
<div>
<header><span>Ruby</span><pre>require 'sinatra/base'  # Use the Sinatra web framework
require 'octokit'       # Use the Octokit Ruby library to interact with GitHub's REST API
require 'dotenv/load'   # Manages environment variables
require 'json'          # Allows your app to manipulate JSON data
require 'openssl'       # Verifies the webhook signature
require 'jwt'           # Authenticates a GitHub App
require 'time'          # Gets ISO 8601 representation of a Time object
require 'logger'        # Logs debug statements

# This code is a Sinatra app, for two reasons:
#   1. Because the app will require a landing page for installation.
#   2. To easily handle webhook events.

class GHAapp &lt; Sinatra::Application

  # Sets the port that's used when starting the web server.
  set :port, 3000
  set :bind, '0.0.0.0'

  # Expects the private key in PEM format. Converts the newlines.
  PRIVATE_KEY = OpenSSL::PKey::RSA.new(ENV['GITHUB_PRIVATE_KEY'].gsub('\n', "\n"))

  # Your registered app must have a webhook secret.
  # The secret is used to verify that webhooks are sent by GitHub.
  WEBHOOK_SECRET = ENV['GITHUB_WEBHOOK_SECRET']

  # The GitHub App's identifier (type integer).
  APP_IDENTIFIER = ENV['GITHUB_APP_IDENTIFIER']

  # Turn on Sinatra's verbose logging during development
  configure :development do
    set :logging, Logger::DEBUG
  end

  # Executed before each request to the `/event_handler` route
  before '/event_handler' do
    get_payload_request(request)
    verify_webhook_signature

    # If a repository name is provided in the webhook, validate that
    # it consists only of latin alphabetic characters, `-`, and `_`.
    unless @payload['repository'].nil?
      halt 400 if (@payload['repository']['name'] =~ /[0-9A-Za-z\-\_]+/).nil?
    end

    authenticate_app
    # Authenticate the app installation in order to run API operations
    authenticate_installation(@payload)
  end

  post '/event_handler' do

    # ADD EVENT HANDLING HERE #

    200 # success status
  end

  helpers do

    # ADD CREATE_CHECK_RUN HELPER METHOD HERE #

    # ADD INITIATE_CHECK_RUN HELPER METHOD HERE #

    # ADD CLONE_REPOSITORY HELPER METHOD HERE #

    # ADD TAKE_REQUESTED_ACTION HELPER METHOD HERE #

    # Saves the raw payload and converts the payload to JSON format
    def get_payload_request(request)
      # request.body is an IO or StringIO object
      # Rewind in case someone already read it
      request.body.rewind
      # The raw text of the body is required for webhook signature verification
      @payload_raw = request.body.read
      begin
        @payload = JSON.parse @payload_raw
      rescue =&gt; e
        fail 'Invalid JSON (#{e}): #{@payload_raw}'
      end
    end

    # Instantiate an Octokit client authenticated as a GitHub App.
    # GitHub App authentication requires that you construct a
    # JWT (https://jwt.io/introduction/) signed with the app's private key,
    # so GitHub can be sure that it came from the app and not altered by
    # a malicious third party.
    def authenticate_app
      payload = {
          # The time that this JWT was issued, _i.e._ now.
          iat: Time.now.to_i,

          # JWT expiration time (10 minute maximum)
          exp: Time.now.to_i + (10 * 60),

          # Your GitHub App's identifier number
          iss: APP_IDENTIFIER
      }

      # Cryptographically sign the JWT.
      jwt = JWT.encode(payload, PRIVATE_KEY, 'RS256')

      # Create the Octokit client, using the JWT as the auth token.
      @app_client ||= Octokit::Client.new(bearer_token: jwt)
    end

    # Instantiate an Octokit client, authenticated as an installation of a
    # GitHub App, to run API operations.
    def authenticate_installation(payload)
      @installation_id = payload['installation']['id']
      @installation_token = @app_client.create_app_installation_access_token(@installation_id)[:token]
      @installation_client = Octokit::Client.new(bearer_token: @installation_token)
    end

    # Check X-Hub-Signature to confirm that this webhook was generated by
    # GitHub, and not a malicious third party.
    #
    # GitHub uses the WEBHOOK_SECRET, registered to the GitHub App, to
    # create the hash signature sent in the `X-HUB-Signature` header of each
    # webhook. This code computes the expected hash signature and compares it to
    # the signature sent in the `X-HUB-Signature` header. If they don't match,
    # this request is an attack, and you should reject it. GitHub uses the HMAC
    # hexdigest to compute the signature. The `X-HUB-Signature` looks something
    # like this: 'sha1=123456'.
    def verify_webhook_signature
      their_signature_header = request.env['HTTP_X_HUB_SIGNATURE'] || 'sha1='
      method, their_digest = their_signature_header.split('=')
      our_digest = OpenSSL::HMAC.hexdigest(method, WEBHOOK_SECRET, @payload_raw)
      halt 401 unless their_digest == our_digest

      # The X-GITHUB-EVENT header provides the name of the event.
      # The action value indicates the which action triggered the event.
      logger.debug "---- received event #{request.env['HTTP_X_GITHUB_EVENT']}"
      logger.debug "----    action #{@payload['action']}" unless @payload['action'].nil?
    end

  end

  # Finally some logic to let us run this server directly from the command line,
  # or with Rack. Don't worry too much about this code. But, for the curious:
  # $0 is the executed file
  # __FILE__ is the current file
  # If they are the same—that is, we are running this file directly, call the
  # Sinatra run method
  run! if __FILE__ == $0
end
</pre></header><pre><code><span>require</span> <span>'sinatra/base'</span>  <span># Use the Sinatra web framework</span>
<span>require</span> <span>'octokit'</span>       <span># Use the Octokit Ruby library to interact with GitHub's REST API</span>
<span>require</span> <span>'dotenv/load'</span>   <span># Manages environment variables</span>
<span>require</span> <span>'json'</span>          <span># Allows your app to manipulate JSON data</span>
<span>require</span> <span>'openssl'</span>       <span># Verifies the webhook signature</span>
<span>require</span> <span>'jwt'</span>           <span># Authenticates a GitHub App</span>
<span>require</span> <span>'time'</span>          <span># Gets ISO 8601 representation of a Time object</span>
<span>require</span> <span>'logger'</span>        <span># Logs debug statements</span>

<span># This code is a Sinatra app, for two reasons:</span>
<span>#   1. Because the app will require a landing page for installation.</span>
<span>#   2. To easily handle webhook events.</span>

<span>class</span> <span>GHAapp</span> &lt; <span>Sinatra::Application</span>

  <span># Sets the port that's used when starting the web server.</span>
  set <span>:port</span>, <span>3000</span>
  set <span>:bind</span>, <span>'0.0.0.0'</span>

  <span># Expects the private key in PEM format. Converts the newlines.</span>
  <span>PRIVATE_KEY</span> = <span>OpenSSL::PKey::RSA</span>.new(<span>ENV</span>[<span>'GITHUB_PRIVATE_KEY'</span>].gsub(<span>'\n'</span>, <span>"\n"</span>))

  <span># Your registered app must have a webhook secret.</span>
  <span># The secret is used to verify that webhooks are sent by GitHub.</span>
  <span>WEBHOOK_SECRET</span> = <span>ENV</span>[<span>'GITHUB_WEBHOOK_SECRET'</span>]

  <span># The GitHub App's identifier (type integer).</span>
  <span>APP_IDENTIFIER</span> = <span>ENV</span>[<span>'GITHUB_APP_IDENTIFIER'</span>]

  <span># Turn on Sinatra's verbose logging during development</span>
  configure <span>:development</span> <span>do</span>
    set <span>:logging</span>, <span>Logger</span><span>:</span><span>:DEBUG</span>
  <span>end</span>

  <span># Executed before each request to the `/event_handler` route</span>
  before <span>'/event_handler'</span> <span>do</span>
    get_payload_request(request)
    verify_webhook_signature

    <span># If a repository name is provided in the webhook, validate that</span>
    <span># it consists only of latin alphabetic characters, `-`, and `_`.</span>
    <span>unless</span> <span>@payload</span>[<span>'repository'</span>].<span>nil</span>?
      halt <span>400</span> <span>if</span> (<span>@payload</span>[<span>'repository'</span>][<span>'name'</span>] =~ <span>/[0-9A-Za-z\-\_]+/</span>).<span>nil</span>?
    <span>end</span>

    authenticate_app
    <span># Authenticate the app installation in order to run API operations</span>
    authenticate_installation(<span>@payload</span>)
  <span>end</span>

  post <span>'/event_handler'</span> <span>do</span>

    <span># ADD EVENT HANDLING HERE #</span>

    <span>200</span> <span># success status</span>
  <span>end</span>

  helpers <span>do</span>

    <span># ADD CREATE_CHECK_RUN HELPER METHOD HERE #</span>

    <span># ADD INITIATE_CHECK_RUN HELPER METHOD HERE #</span>

    <span># ADD CLONE_REPOSITORY HELPER METHOD HERE #</span>

    <span># ADD TAKE_REQUESTED_ACTION HELPER METHOD HERE #</span>

    <span># Saves the raw payload and converts the payload to JSON format</span>
    <span>def</span> <span>get_payload_request</span>(<span>request</span>)
      <span># request.body is an IO or StringIO object</span>
      <span># Rewind in case someone already read it</span>
      request.body.rewind
      <span># The raw text of the body is required for webhook signature verification</span>
      <span>@payload_raw</span> = request.body.read
      <span>begin</span>
        <span>@payload</span> = <span>JSON</span>.parse <span>@payload_raw</span>
      <span>rescue</span> =&gt; e
        fail <span>'Invalid JSON (<span>#{e}</span>): <span>#{<span>@payload_raw</span>}</span>'</span>
      <span>end</span>
    <span>end</span>

    <span># Instantiate an Octokit client authenticated as a GitHub App.</span>
    <span># GitHub App authentication requires that you construct a</span>
    <span># JWT (https://jwt.io/introduction/) signed with the app's private key,</span>
    <span># so GitHub can be sure that it came from the app and not altered by</span>
    <span># a malicious third party.</span>
    <span>def</span> <span>authenticate_app</span>
      payload = {
          <span># The time that this JWT was issued, _i.e._ now.</span>
          <span>iat:</span> <span>Time</span>.now.to_i,

          <span># JWT expiration time (10 minute maximum)</span>
          <span>exp:</span> <span>Time</span>.now.to_i + (<span>10</span> * <span>60</span>),

          <span># Your GitHub App's identifier number</span>
          <span>iss:</span> <span>APP_IDENTIFIER</span>
      }

      <span># Cryptographically sign the JWT.</span>
      jwt = <span>JWT</span>.encode(payload, <span>PRIVATE_KEY</span>, <span>'RS256'</span>)

      <span># Create the Octokit client, using the JWT as the auth token.</span>
      <span>@app_client</span> |<span>Octokit::Client</span>.new(<span>bearer_token:</span> jwt)
    <span>end</span>

    <span># Instantiate an Octokit client, authenticated as an installation of a</span>
    <span># GitHub App, to run API operations.</span>
    <span>def</span> <span>authenticate_installation</span>(<span>payload</span>)
      <span>@installation_id</span> = payload[<span>'installation'</span>][<span>'id'</span>]
      <span>@installation_token</span> = <span>@app_client</span>.create_app_installation_access_token(<span>@installation_id</span>)[<span>:token</span>]
      <span>@installation_client</span> = <span>Octokit::Client</span>.new(<span>bearer_token:</span> <span>@installation_token</span>)
    <span>end</span>

    <span># Check X-Hub-Signature to confirm that this webhook was generated by</span>
    <span># GitHub, and not a malicious third party.</span>
    <span>#</span>
    <span># GitHub uses the WEBHOOK_SECRET, registered to the GitHub App, to</span>
    <span># create the hash signature sent in the `X-HUB-Signature` header of each</span>
    <span># webhook. This code computes the expected hash signature and compares it to</span>
    <span># the signature sent in the `X-HUB-Signature` header. If they don't match,</span>
    <span># this request is an attack, and you should reject it. GitHub uses the HMAC</span>
    <span># hexdigest to compute the signature. The `X-HUB-Signature` looks something</span>
    <span># like this: 'sha1=123456'.</span>
    <span>def</span> <span>verify_webhook_signature</span>
      their_signature_header = request.env[<span>'HTTP_X_HUB_SIGNATURE'</span>] |<span>'sha1='</span>
      method, their_digest = their_signature_header.split(<span>'='</span>)
      our_digest = <span>Open</span>SSL::<span>HMAC</span>.hexdigest(method, <span>WEBHOOK_SECRET</span>, <span>@payload_raw</span>)
      halt <span>401</span> <span>unless</span> their_digest == our_digest

      <span># The X-GITHUB-EVENT header provides the name of the event.</span>
      <span># The action value indicates the which action triggered the event.</span>
      logger.debug <span>"---- received event <span>#{request.env[<span>'HTTP_X_GITHUB_EVENT'</span>]}</span>"</span>
      logger.debug <span>"----    action <span>#{<span>@payload</span>[<span>'action'</span>]}</span>"</span> <span>unless</span> <span>@payload</span>[<span>'action'</span>].<span>nil</span>?
    <span>end</span>

  <span>end</span>

  <span># Finally some logic to let us run this server directly from the command line,</span>
  <span># or with Rack. Don't worry too much about this code. But, for the curious:</span>
  <span># $0 is the executed file</span>
  <span># __FILE__ is the current file</span>
  <span># If they are the same—that is, we are running this file directly, call the</span>
  <span># Sinatra run method</span>
  run! <span>if</span> <span>__FILE__</span> == <span>$0</span>
<span>end</span>
</code></pre>
</div>
<p>The rest of this section will explain what the template code does. There aren't any steps that you need to complete in this section. If you're already familiar with the template code, you can skip ahead to <a href="#start-the-server">Start the server</a>.</p>
<h3><a href="#understand-the-template-code">Understand the template code</a></h3>
<p>Open the <code>server.rb</code> file in a text editor. You'll see comments throughout the file that provide additional context for the template code. We recommend reading those comments carefully and even adding your own comments to accompany new code you write.</p>
<p>Below the list of required files, the first code you'll see is the <code>class GHApp &lt; Sinatra::Application</code> declaration. You'll write all of the code for your GitHub App inside this class. The following sections explain in detail what the code does inside this class.</p>
<ul>
<li><a href="#set-the-port">Set the port</a></li>
<li><a href="#read-the-environment-variables">Read the environment variables</a></li>
<li><a href="#turn-on-logging">Turn on logging</a></li>
<li><a href="#define-a-before-filter">Define a <code>before</code> filter</a></li>
<li><a href="#define-a-route-handler">Define the route handler</a></li>
<li><a href="#define-the-helper-methods">Define the helper methods</a></li>
</ul>
<h4><a href="#set-the-port">Set the port</a></h4>
<p>The first thing you'll see inside the <code>class GHApp &lt; Sinatra::Application</code> declaration is <code>set :port 3000</code>. This sets the port used when starting the web server, to match the port you redirected your webhook payloads to in <a href="#get-a-webhook-proxy-url">Get a Webhook Proxy URL</a>.</p>
<pre><code>  <span># Sets the port that's used when starting the web server.</span>
  set <span>:port</span>, <span>3000</span>
  set <span>:bind</span>, <span>'0.0.0.0'</span>
</code></pre>
<h4><a href="#read-the-environment-variables">Read the environment variables</a></h4>
<p>Next, this class reads the three environment variables you set in <a href="#store-your-apps-identifying-information-and-credentials">Store your app's identifying information and credentials</a>, and stores them in variables to use later.</p>
<pre><code><span># Expects the private key in PEM format. Converts the newlines.</span>
<span>PRIVATE_KEY</span> = <span>OpenSSL::PKey::RSA</span>.new(<span>ENV</span>[<span>'GITHUB_PRIVATE_KEY'</span>].gsub(<span>'\n'</span>, <span>"\n"</span>))

<span># Your registered app must have a webhook secret.</span>
<span># The secret is used to verify that webhooks are sent by GitHub.</span>
<span>WEBHOOK_SECRET</span> = <span>ENV</span>[<span>'GITHUB_WEBHOOK_SECRET'</span>]

<span># The GitHub App's identifier (type integer).</span>
<span>APP_IDENTIFIER</span> = <span>ENV</span>[<span>'GITHUB_APP_IDENTIFIER'</span>]
</code></pre>
<h4><a href="#turn-on-logging">Turn on logging</a></h4>
<p>Next is a code block that enables logging during development, which is the default environment in Sinatra. This code turns on logging at the <code>DEBUG</code> level to show useful output in the terminal while you are developing the app.</p>
<pre><code><span># Turn on Sinatra's verbose logging during development</span>
configure <span>:development</span> <span>do</span>
  set <span>:logging</span>, <span>Logger</span><span>:</span><span>:DEBUG</span>
<span>end</span>
</code></pre>
<h4><a href="#define-a-before-filter">Define a <code>before</code> filter</a></h4>
<p>Sinatra uses <code>before</code> filters that allow you to execute code before the route handler. The <code>before</code> block in the template calls four helper methods: <code>get_payload_request</code>, <code>verify_webhook_signature</code>, <code>authenticate_app</code>, and <code>authenticate_installation</code>. For more information, see <a href="https://github.com/sinatra/sinatra#filters">Filters</a> and <a href="https://github.com/sinatra/sinatra#helpers">Helpers</a> in the Sinatra documentation.</p>
<pre><code>  <span># Executed before each request to the `/event_handler` route</span>
  before <span>'/event_handler'</span> <span>do</span>
    get_payload_request(request)
    verify_webhook_signature

    <span># If a repository name is provided in the webhook, validate that</span>
    <span># it consists only of latin alphabetic characters, `-`, and `_`.</span>
    <span>unless</span> <span>@payload</span>[<span>'repository'</span>].<span>nil</span>?
      halt <span>400</span> <span>if</span> (<span>@payload</span>[<span>'repository'</span>][<span>'name'</span>] =~ <span>/[0-9A-Za-z\-\_]+/</span>).<span>nil</span>?
    <span>end</span>

    authenticate_app
    <span># Authenticate the app installation in order to run API operations</span>
    authenticate_installation(<span>@payload</span>)
  <span>end</span>
</code></pre>
<p>Each of these helper methods are defined later in the code, in the code block that starts with <code>helpers do</code>. For more information, see <a href="#define-the-helper-methods">Define the helper methods</a>.</p>
<p>Under <code>verify_webhook_signature</code>, the code that starts with <code>unless @payload</code> is a security measure. If a repository name is provided with a webhook payload, this code validates that the repository name contains only Latin alphabetic characters, hyphens, and underscores. This helps ensure that a bad actor isn't attempting to execute arbitrary commands or inject false repository names. Later, in the code block that starts with <code>helpers do</code>, the <code>verify_webhook_signature</code> helper method also validates incoming webhook payloads as an additional security measure.</p>
<h4><a href="#define-a-route-handler">Define a route handler</a></h4>
<p>An empty route is included in the template code. This code handles all <code>POST</code> requests to the <code>/event_handler</code> route. You will add more code to this later.</p>
<pre><code>post <span>'/event_handler'</span> <span>do</span>

<span>end</span>
</code></pre>
<h4><a href="#define-the-helper-methods">Define the helper methods</a></h4>
<p>Four helper methods are called in the <code>before</code> block of the template code. The <code>helpers do</code> code block defines each of these helper methods.</p>
<h5><a href="#handling-the-webhook-payload">Handling the webhook payload</a></h5>
<p>The first helper method <code>get_payload_request</code> captures the webhook payload and converts it to JSON format, which makes accessing the payload's data much easier.</p>
<h5><a href="#verifying-the-webhook-signature">Verifying the webhook signature</a></h5>
<p>The second helper method <code>verify_webhook_signature</code> performs verification of the webhook signature to ensure that GitHub generated the event. To learn more about the code in the <code>verify_webhook_signature</code> helper method, see <a href="/en/webhooks-and-events/webhooks/securing-your-webhooks">Validating webhook deliveries</a>. If the webhooks are secure, this method will log all incoming payloads to your terminal. The logger code is helpful in verifying your web server is working.</p>
<h5><a href="#authenticating-as-a-github-app">Authenticating as a GitHub App</a></h5>
<p>The third helper method <code>authenticate_app</code> allows your GitHub App to authenticate, so it can request an installation token.</p>
<p>To make API calls, you'll be using the Octokit library. Doing anything interesting with this library will require your GitHub App to authenticate. For more information about the Octokit library, see the <a href="https://octokit.github.io/octokit.rb/">Octokit documentation</a>.</p>
<p>GitHub Apps have three methods of authentication:</p>
<ul>
<li>Authenticating as a GitHub App using a <a href="https://jwt.io/introduction">JSON Web Token (JWT)</a>.</li>
<li>Authenticating as a specific installation of a GitHub App using an installation access token.</li>
<li>Authenticating on behalf of a user. This tutorial won't use this method of authentication.</li>
</ul>
<p>You'll learn about authenticating as an installation in the next section, <a href="#authenticating-as-an-installation">Authenticating as an installation</a>.</p>
<p>Authenticating as a GitHub App lets you do a couple of things:</p>
<ul>
<li>You can retrieve high-level management information about your GitHub App.</li>
<li>You can request access tokens for an installation of the app.</li>
</ul>
<p>For example, you would authenticate as a GitHub App to retrieve a list of the accounts (organization and personal) that have installed your app. But this authentication method doesn't allow you to do much with the API. To access a repository's data and perform operations on behalf of the installation, you need to authenticate as an installation. To do that, you'll need to authenticate as a GitHub App first to request an installation access token. For more information, see <a href="/en/apps/creating-github-apps/authenticating-with-a-github-app/about-authentication-with-a-github-app">About authentication with a GitHub App</a>.</p>
<p>Before you can use the Octokit.rb library to make API calls, you'll need to initialize an <a href="https://octokit.github.io/octokit.rb/Octokit/Client.html">Octokit client</a> authenticated as a GitHub App, using the <code>authenticate_app</code> helper method.</p>
<pre><code><span># Instantiate an Octokit client authenticated as a GitHub App.</span>
<span># GitHub App authentication requires that you construct a</span>
<span># JWT (https://jwt.io/introduction/) signed with the app's private key,</span>
<span># so GitHub can be sure that it came from the app an not altered by</span>
<span># a malicious third party.</span>
<span>def</span> <span>authenticate_app</span>
  payload = {
      <span># The time that this JWT was issued, _i.e._ now.</span>
      <span>iat:</span> <span>Time</span>.now.to_i,

      <span># JWT expiration time (10 minute maximum)</span>
      <span>exp:</span> <span>Time</span>.now.to_i + (<span>10</span> * <span>60</span>),

      <span># Your GitHub App's identifier number</span>
      <span>iss:</span> <span>APP_IDENTIFIER</span>
  }

  <span># Cryptographically sign the JWT</span>
  jwt = <span>JWT</span>.encode(payload, <span>PRIVATE_KEY</span>, <span>'RS256'</span>)

  <span># Create the Octokit client, using the JWT as the auth token.</span>
  <span>@app_client</span> |<span>Octokit::Client</span>.new(<span>bearer_token:</span> jwt)
<span>end</span>
</code></pre>
<p>The code above generates a JSON Web Token (JWT) and uses it (along with your app's private key) to initialize the Octokit client. GitHub checks a request's authentication by verifying the token with the app's stored public key. To learn more about how this code works, see <a href="/en/apps/creating-github-apps/authenticating-with-a-github-app/generating-a-json-web-token-jwt-for-a-github-app">Generating a JSON Web Token (JWT) for a GitHub App</a>.</p>
<h5><a href="#authenticating-as-an-installation">Authenticating as an installation</a></h5>
<p>The fourth and final helper method, <code>authenticate_installation</code>, initializes an <a href="https://octokit.github.io/octokit.rb/Octokit/Client.html">Octokit client</a> authenticated as an installation, which you can use to make authenticated calls to the API.</p>
<p>An <em>installation</em> refers to any user or organization account that has installed the app. Even if someone grants the app access to more than one repository on that account, it only counts as one installation because it's within the same account.</p>
<pre><code><span># Instantiate an Octokit client authenticated as an installation of a</span>
<span># GitHub App to run API operations.</span>
<span>def</span> <span>authenticate_installation</span>(<span>payload</span>)
  installation_id = payload[<span>'installation'</span>][<span>'id'</span>]
  installation_token = <span>@app_client</span>.create_app_installation_access_token(installation_id)[<span>:token</span>]
  <span>@installation_client</span> = <span>Octokit::Client</span>.new(<span>bearer_token:</span> installation_token)
<span>end</span>
</code></pre>
<p>The <code>create_app_installation_access_token</code> Octokit method creates an installation token. For more information, see <a href="https://octokit.github.io/octokit.rb/Octokit/Client/Apps.html#create_app_installation_access_token-instance_method">create_installation_access_token</a> in the Octokit documentation.</p>
<p>This method accepts two arguments:</p>
<ul>
<li>Installation (integer): The ID of a GitHub App installation</li>
<li>Options (hash, defaults to <code>{}</code>): A customizable set of options</li>
</ul>
<p>Any time a GitHub App receives a webhook, it includes an <code>installation</code> object with an <code>id</code>. Using the client authenticated as a GitHub App, you pass this ID to the <code>create_app_installation_access_token</code> method to generate an access token for each installation. Since you're not passing any options to the method, the options default to an empty hash. The response for <code>create_app_installation_access_token</code> includes two fields: <code>token</code> and <code>expired_at</code>. The template code selects the token in the response and initializes an installation client.</p>
<p>With this method in place, each time your app receives a new webhook payload, it creates a client for the installation that triggered the event. This authentication process enables your GitHub App to work for all installations on any account.</p>
<h2><a href="#start-the-server">Start the server</a></h2>
<p>Your app doesn't do anything yet, but at this point, you can get it running on the server.</p>
<ol>
<li>
<p>In your terminal, make sure that Smee is still running. For more information, see <a href="#get-a-webhook-proxy-url">Get a webhook proxy URL</a>.</p>
</li>
<li>
<p>Open a new tab in your terminal, and <code>cd</code> into the directory where you cloned the repository that you created earlier in the tutorial. For more information, see <a href="#create-a-repository-to-store-code-for-your-github-app">Create a repository to store code for your GitHub App</a>. The Ruby code in this repository will start up a <a href="https://sinatrarb.com/">Sinatra</a> web server.</p>
</li>
<li>
<p>Install the dependencies by running the following two commands one after the other:</p>
<div>
<header><span>Shell</span><pre>gem install bundler
</pre></header><pre><code>gem install bundler
</code></pre>
</div>
<div>
<header><span>Shell</span><pre>bundle install
</pre></header><pre><code>bundle install
</code></pre>
</div>
</li>
<li>
<p>After installing the dependencies, start the server by running this command:</p>
<div>
<header><span>Shell</span><pre>bundle exec ruby server.rb
</pre></header><pre><code>bundle exec ruby server.rb
</code></pre>
</div>
<p>You should see a response like this:</p>
<pre><code><span>&gt; </span><span>== Sinatra (v2.2.3) has taken the stage on 3000 <span>for</span> development with backup from Puma</span>
<span>&gt; </span><span>Puma starting <span>in</span> single mode...</span>
<span>&gt; </span><span>* Puma version: 6.3.0 (ruby 3.1.2-p20) (<span>"Mugi No Toki Itaru"</span>)</span>
<span>&gt; </span><span>*  Min threads: 0</span>
<span>&gt; </span><span>*  Max threads: 5</span>
<span>&gt; </span><span>*  Environment: development</span>
<span>&gt; </span><span>*          PID: 14915</span>
<span>&gt; </span><span>* Listening on http://0.0.0.0:3000</span>
<span>&gt; </span><span>Use Ctrl-C to stop</span>
</code></pre>
<p>If you see an error, make sure you've created the <code>.env</code> file in the directory that contains <code>server.rb</code>.</p>
</li>
<li>
<p>To test the server, navigate in your browser to <code>http://localhost:3000</code>.</p>
<p>If you see an error page that says "Sinatra doesn't know this ditty," the app is working as expected. Even though it's an error page, it's a Sinatra error page, which means your app is connected to the server as expected. You're seeing this message because you haven't given the app anything else to show.</p>
</li>
</ol>
<h2><a href="#test-that-the-server-is-listening-to-your-app">Test that the server is listening to your app</a></h2>
<p>You can test that the server is listening to your app by triggering an event for it to receive. You'll do that by installing the app on a test repository, which will send the <a href="/en/webhooks-and-events/webhooks/webhook-events-and-payloads#installation"><code>installation</code> event</a> to your app. If the app receives it, you should see output in the terminal tab where you're running <code>server.rb</code>.</p>
<ol>
<li>
<p>Create a new repository to use for testing your tutorial code. For more information, see <a href="/en/repositories/creating-and-managing-repositories/creating-a-new-repository">Creating a new repository</a>.</p>
</li>
<li>
<p>Install the GitHub App on the repository you just created. For more information, see <a href="/en/apps/using-github-apps/installing-your-own-github-app#installing-your-own-github-app">Installing your own GitHub App</a>. During the installation process, choose <strong>Only select repositories</strong>, and select the repository you created in the previous step.</p>
</li>
<li>
<p>After you click <strong>Install</strong>, look at the output in the terminal tab where you're running <code>server.rb</code>. You should see something like this:</p>
<pre><code><span>&gt; </span><span>D, [2023-06-08T15:45:43.773077 <span>#30488] DEBUG -- : ---- received event installation</span></span>
<span>&gt; </span><span>D, [2023-06-08T15:45:43.773141 <span>#30488]] DEBUG -- : ----    action created</span></span>
<span>&gt; </span><span>192.30.252.44 - - [08/Jun/2023:15:45:43 -0400] <span>"POST /event_handler HTTP/1.1"</span> 200 - 0.5390</span>
</code></pre>
<p>If you see output like this, it means your app received a notification that it was installed on your GitHub account. The app is running on the server as expected.</p>
<p>If you don't see this output, make sure Smee is running correctly in another terminal tab. If you need to restart Smee, note that you'll also need to <em>uninstall</em> and <em>reinstall</em> the app to send the <code>installation</code> event to your app again and see the output in terminal.</p>
</li>
</ol>
<p>If you're wondering where the terminal output above is coming from, it's written in the app template code you added to <code>server.rb</code> in <a href="#add-code-for-your-github-app">Add code for your GitHub App</a>.</p>
<h2><a href="#part-1-creating-the-checks-api-interface">Part 1. Creating the Checks API interface</a></h2>
<p>In this part, you will add the code necessary to receive <code>check_suite</code> webhook events, and create and update check runs. You'll also learn how to create check runs when a check was re-requested on GitHub. At the end of this section, you'll be able to view the check run you created in a GitHub pull request.</p>
<p>Your check run will not perform any checks on the code in this section. You'll add that functionality in <a href="#part-2-creating-a-ci-test">Part 2: Creating a CI test</a>.</p>
<p>You should already have a Smee channel configured that is forwarding webhook payloads to your local server. Your server should be running and connected to the GitHub App you registered and installed on a test repository.</p>
<p>These are the steps you'll complete in Part 1:</p>
<ol>
<li><a href="#step-11-add-event-handling">Add event handling</a></li>
<li><a href="#step-12-create-a-check-run">Create a check run</a></li>
<li><a href="#step-13-update-a-check-run">Update a check run</a></li>
</ol>
<h2><a href="#step-11-add-event-handling">Step 1.1. Add event handling</a></h2>
<p>Because your app is subscribed to the <strong>Check suite</strong> and <strong>Check run</strong> events, it will receive the <a href="/en/webhooks-and-events/webhooks/webhook-events-and-payloads#check_suite"><code>check_suite</code></a> and <a href="/en/webhooks-and-events/webhooks/webhook-events-and-payloads#check_run"><code>check_run</code></a> webhooks. GitHub sends webhook payloads as <code>POST</code> requests. Because you forwarded your Smee webhook payloads to <code>http://localhost:3000/event_handler</code>, your server will receive the <code>POST</code> request payloads at the <code>post '/event_handler'</code> route.</p>
<p>Open the <code>server.rb</code> file that you created in <a href="#add-code-for-your-github-app">Add code for your GitHub App</a>, and look for the following code. An empty <code>post '/event_handler'</code> route is already included in the template code. The empty route looks like this:</p>
<pre><code>  post <span>'/event_handler'</span> <span>do</span>

    <span># ADD EVENT HANDLING HERE #</span>

    <span>200</span> <span># success status</span>
  <span>end</span>
</code></pre>
<p>In the code block that starts with <code>post '/event_handler' do</code>, where it says <code># ADD EVENT HANDLING HERE #</code>, add the following code. This route will handle the <code>check_suite</code> event.</p>
<div>
<header><span>Ruby</span><pre>    # Get the event type from the HTTP_X_GITHUB_EVENT header
    case request.env['HTTP_X_GITHUB_EVENT']
    when 'check_suite'
      # A new check_suite has been created. Create a new check run with status queued
      if @payload['action'] == 'requested' || @payload['action'] == 'rerequested'
        create_check_run
      end
      # ADD CHECK_RUN METHOD HERE #
    end
</pre></header><pre><code>    <span># Get the event type from the HTTP_X_GITHUB_EVENT header</span>
    <span>case</span> request.env[<span>'HTTP_X_GITHUB_EVENT'</span>]
    <span>when</span> <span>'check_suite'</span>
      <span># A new check_suite has been created. Create a new check run with status queued</span>
      <span>if</span> <span>@payload</span>[<span>'action'</span>] == <span>'requested'</span> |<span>@payload</span>[<span>'action'</span>] == <span>'rerequested'</span>
        create_check_run
      <span>end</span>
      <span># ADD CHECK_RUN METHOD HERE #</span>
    <span>end</span>
</code></pre>
</div>
<p>Every event that GitHub sends includes a request header called <code>HTTP_X_GITHUB_EVENT</code>, which indicates the type of event in the <code>POST</code> request. Right now, you're only interested in events of type <code>check_suite</code>, which are emitted when a new check suite is created. Each event has an additional <code>action</code> field that indicates the type of action that triggered the events. For <code>check_suite</code>, the <code>action</code> field can be <code>requested</code>, <code>rerequested</code>, or <code>completed</code>.</p>
<p>The <code>requested</code> action requests a check run each time code is pushed to the repository, while the <code>rerequested</code> action requests that you re-run a check for code that already exists in the repository. Because both the <code>requested</code> and <code>rerequested</code> actions require creating a check run, you'll call a helper called <code>create_check_run</code>. Let's write that method now.</p>
<h2><a href="#step-12-create-a-check-run">Step 1.2. Create a check run</a></h2>
<p>You'll add this new method as a <a href="https://github.com/sinatra/sinatra#helpers">Sinatra helper</a> in case you want other routes to use it too.</p>
<p>In the code block that starts with <code>helpers do</code>, where it says <code># ADD CREATE_CHECK_RUN HELPER METHOD HERE #</code>, add the following code:</p>
<div>
<header><span>Ruby</span><pre>    # Create a new check run with status "queued"
    def create_check_run
      @installation_client.create_check_run(
        # [String, Integer, Hash, Octokit Repository object] A GitHub repository.
        @payload['repository']['full_name'],
        # [String] The name of your check run.
        'Octo RuboCop',
        # [String] The SHA of the commit to check
        # The payload structure differs depending on whether a check run or a check suite event occurred.
        @payload['check_run'].nil? ? @payload['check_suite']['head_sha'] : @payload['check_run']['head_sha'],
        # [Hash] 'Accept' header option, to avoid a warning about the API not being ready for production use.
        accept: 'application/vnd.github+json'
      )
    end
</pre></header><pre><code>    <span># Create a new check run with status "queued"</span>
    <span>def</span> <span>create_check_run</span>
      <span>@installation_client</span>.create_check_run(
        <span># [String, Integer, Hash, Octokit Repository object] A GitHub repository.</span>
        <span>@payload</span>[<span>'repository'</span>][<span>'full_name'</span>],
        <span># [String] The name of your check run.</span>
        <span>'Octo RuboCop'</span>,
        <span># [String] The SHA of the commit to check</span>
        <span># The payload structure differs depending on whether a check run or a check suite event occurred.</span>
        <span>@payload</span>[<span>'check_run'</span>].<span>nil</span>? ? <span>@payload</span>[<span>'check_suite'</span>][<span>'head_sha'</span>] : <span>@payload</span>[<span>'check_run'</span>][<span>'head_sha'</span>],
        <span># [Hash] 'Accept' header option, to avoid a warning about the API not being ready for production use.</span>
        <span>accept:</span> <span>'application/vnd.github+json'</span>
      )
    <span>end</span>
</code></pre>
</div>
<p>This code calls the <code>POST /repos/{owner}/{repo}/check-runs</code> endpoint using the Octokit <a href="https://msp-greg.github.io/octokit/Octokit/Client/Checks.html#create_check_run-instance_method">create_check_run method</a>. For more information about the endpoint, see <a href="/en/rest/checks/runs#create-a-check-run">REST API endpoints for check runs</a>.</p>
<p>To create a check run, only two input parameters are required: <code>name</code> and <code>head_sha</code>. In this code, we name the check run "Octo RuboCop," because we'll use RuboCop to implement the CI test later in the tutorial. But you can choose any name you'd like for the check run. For more information about RuboCop, see the <a href="https://docs.rubocop.org/rubocop/index.html">RuboCop documentation</a>.</p>
<p>You're only supplying the required parameters now to get the basic functionality working, but you'll update the check run later as you collect more information about the check run. By default, GitHub sets the <code>status</code> to <code>queued</code>.</p>
<p>GitHub creates a check run for a specific commit SHA, which is why <code>head_sha</code> is a required parameter. You can find the commit SHA in the webhook payload. Although you're only creating a check run for the <code>check_suite</code> event right now, it's good to know that the <code>head_sha</code> is included in both the <code>check_suite</code> and <code>check_run</code> objects in the event payloads.</p>
<p>The code above uses a <a href="https://ruby-doc.org/core-2.3.0/doc/syntax/control_expressions_rdoc.html#label-Ternary+if">ternary operator</a>, which works like an <code>if/else</code> statement, to check if the payload contains a <code>check_run</code> object. If it does, you read the <code>head_sha</code> from the <code>check_run</code> object, otherwise you read it from the <code>check_suite</code> object.</p>
<h3><a href="#test-the-code">Test the code</a></h3>
<p>The following steps will show you how to test that the code works, and that it successfully creates a new check run.</p>
<ol>
<li>
<p>Run the following command to restart the server from your terminal. If the server is already running, first enter <code>Ctrl-C</code> in your terminal to stop the server, and then run the following command to start the server again.</p>
<div>
<header><span>Shell</span><pre>ruby server.rb
</pre></header><pre><code>ruby server.rb
</code></pre>
</div>
</li>
<li>
<p>Create a pull request in the test repository you created in <a href="#test-that-the-server-is-listening-to-your-app">Test that the server is listening to your app</a>. This is the repository that you granted the app access to.</p>
</li>
<li>
<p>In the pull request you just created, navigate to the <strong>Checks</strong> tab. You should see a check run with the name "Octo RuboCop," or whichever name you chose earlier for the check run.</p>
</li>
</ol>
<p>If you see other apps in the <strong>Checks</strong> tab, it means you have other apps installed on your repository that have <strong>Read &amp; write</strong> access to checks and are subscribed to <strong>Check suite</strong> and <strong>Check run</strong> events. It may also mean that you have GitHub Actions workflows on the repository that are triggered by the <code>pull_request</code> or <code>pull_request_target</code> event.</p>
<p>So far you've told GitHub to create a check run. The check run status in the pull request is set to queued with a yellow icon. In the next step, you will wait for GitHub to create the check run and update its status.</p>
<h2><a href="#step-13-update-a-check-run">Step 1.3. Update a check run</a></h2>
<p>When your <code>create_check_run</code> method runs, it asks GitHub to create a new check run. When GitHub finishes creating the check run, you'll receive the <code>check_run</code> webhook event with the <code>created</code> action. That event is your signal to begin running the check.</p>
<p>You'll update your event handler to look for the <code>created</code> action. While you're updating the event handler, you can add a conditional for the <code>rerequested</code> action. When someone re-runs a single test on GitHub by clicking the "Re-run" button, GitHub sends the <code>rerequested</code> check run event to your app. When a check run is <code>rerequested</code>, you'll start the process all over and create a new check run. To do that, you'll include a condition for the <code>check_run</code> event in the <code>post '/event_handler'</code> route.</p>
<p>In the code block that starts with <code>post '/event_handler' do</code>, where it says <code># ADD CHECK_RUN METHOD HERE #</code>, add the following code:</p>
<div>
<header><span>Ruby</span><pre>    when 'check_run'
      # Check that the event is being sent to this app
      if @payload['check_run']['app']['id'].to_s === APP_IDENTIFIER
        case @payload['action']
        when 'created'
          initiate_check_run
        when 'rerequested'
          create_check_run
        # ADD REQUESTED_ACTION METHOD HERE #
        end
      end
</pre></header><pre><code>    <span>when</span> <span>'check_run'</span>
      <span># Check that the event is being sent to this app</span>
      <span>if</span> <span>@payload</span>[<span>'check_run'</span>][<span>'app'</span>][<span>'id'</span>].to_s === <span>APP_IDENTIFIER</span>
        <span>case</span> <span>@payload</span>[<span>'action'</span>]
        <span>when</span> <span>'created'</span>
          initiate_check_run
        <span>when</span> <span>'rerequested'</span>
          create_check_run
        <span># ADD REQUESTED_ACTION METHOD HERE #</span>
        <span>end</span>
      <span>end</span>
</code></pre>
</div>
<p>GitHub sends all events for <code>created</code> check runs to every app installed on a repository that has the necessary checks permissions. That means that your app will receive check runs created by other apps. A <code>created</code> check run is a little different from a <code>requested</code> or <code>rerequested</code> check suite, which GitHub sends only to apps that are being requested to run a check. The code above looks for the check run's application ID. This filters out all check runs for other apps on the repository.</p>
<p>Next you'll write the <code>initiate_check_run</code> method, which is where you'll update the check run status and prepare to kick off your CI test.</p>
<p>In this section, you're not going to kick off the CI test yet, but you'll walk through how to update the status of the check run from <code>queued</code> to <code>pending</code> and then from <code>pending</code> to <code>completed</code> to see the overall flow of a check run. In <a href="#part-2-creating-a-ci-test">Part 2: Creating a CI test</a>, you'll add the code that actually performs the CI test.</p>
<p>Let's create the <code>initiate_check_run</code> method and update the status of the check run.</p>
<p>In the code block that starts with <code>helpers do</code>, where it says <code># ADD INITIATE_CHECK_RUN HELPER METHOD HERE #</code>, add the following code:</p>
<div>
<header><span>Ruby</span><pre>    # Start the CI process
    def initiate_check_run
      # Once the check run is created, you'll update the status of the check run
      # to 'in_progress' and run the CI process. When the CI finishes, you'll
      # update the check run status to 'completed' and add the CI results.

      @installation_client.update_check_run(
        @payload['repository']['full_name'],
        @payload['check_run']['id'],
        status: 'in_progress',
        accept: 'application/vnd.github+json'
      )

      # ***** RUN A CI TEST *****

      # Mark the check run as complete!
      @installation_client.update_check_run(
        @payload['repository']['full_name'],
        @payload['check_run']['id'],
        status: 'completed',
        conclusion: 'success',
        accept: 'application/vnd.github+json'
      )

    end
</pre></header><pre><code>    <span># Start the CI process</span>
    <span>def</span> <span>initiate_check_run</span>
      <span># Once the check run is created, you'll update the status of the check run</span>
      <span># to 'in_progress' and run the CI process. When the CI finishes, you'll</span>
      <span># update the check run status to 'completed' and add the CI results.</span>

      <span>@installation_client</span>.update_check_run(
        <span>@payload</span>[<span>'repository'</span>][<span>'full_name'</span>],
        <span>@payload</span>[<span>'check_run'</span>][<span>'id'</span>],
        <span>status:</span> <span>'in_progress'</span>,
        <span>accept:</span> <span>'application/vnd.github+json'</span>
      )

      <span># ***** RUN A CI TEST *****</span>

      <span># Mark the check run as complete!</span>
      <span>@installation_client</span>.update_check_run(
        <span>@payload</span>[<span>'repository'</span>][<span>'full_name'</span>],
        <span>@payload</span>[<span>'check_run'</span>][<span>'id'</span>],
        <span>status:</span> <span>'completed'</span>,
        <span>conclusion:</span> <span>'success'</span>,
        <span>accept:</span> <span>'application/vnd.github+json'</span>
      )

    <span>end</span>
</code></pre>
</div>
<p>The code above calls the <code>PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}</code> endpoint using the <a href="https://msp-greg.github.io/octokit/Octokit/Client/Checks.html#update_check_run-instance_method"><code>update_check_run</code> Octokit method</a>, and updates the check run that you already created. For more information about the endpoint, see <a href="/en/rest/checks/runs#update-a-check-run">REST API endpoints for check runs</a>.</p>
<p>Here's what this code is doing. First, it updates the check run's status to <code>in_progress</code> and implicitly sets the <code>started_at</code> time to the current time. In Part 2 of this tutorial, you'll add code that kicks off a real CI test under <code>***** RUN A CI TEST *****</code>. For now, you'll leave that section as a placeholder, so the code that follows it will just simulate that the CI process succeeds and all tests pass. Finally, the code updates the status of the check run again to <code>completed</code>.</p>
<p>When you use the REST API to provide a check run status of <code>completed</code>, the <code>conclusion</code> and <code>completed_at</code> parameters are required. The <code>conclusion</code> summarizes the outcome of a check run and can be <code>success</code>, <code>failure</code>, <code>neutral</code>, <code>cancelled</code>, <code>timed_out</code>, <code>skipped</code>, or <code>action_required</code>. You'll set the conclusion to <code>success</code>, the <code>completed_at</code> time to the current time, and the status to <code>completed</code>.</p>
<p>You could also provide more details about what your check is doing, but you'll get to that in the next section.</p>
<h3><a href="#test-the-code-1">Test the code</a></h3>
<p>The following steps will show you how to test that the code works, and that the new "Re-run all" button you created works.</p>
<ol>
<li>
<p>Run the following command to restart the server from your terminal. If the server is already running, first enter <code>Ctrl-C</code> in your terminal to stop the server, and then run the following command to start the server again.</p>
<div>
<header><span>Shell</span><pre>ruby server.rb
</pre></header><pre><code>ruby server.rb
</code></pre>
</div>
</li>
<li>
<p>Create a pull request in the test repository you created in <a href="#test-that-the-server-is-listening-to-your-app">Test that the server is listening to your app</a>. This is the repository that you granted the app access to.</p>
</li>
<li>
<p>In the pull request you just created, navigate to the <strong>Checks</strong> tab. You should see a "Re-run all" button.</p>
</li>
<li>
<p>Click the "Re-run all" button in the upper right corner. The test should run again, and end with <code>success</code>.</p>
</li>
</ol>
<h2><a href="#part-2-creating-a-ci-test">Part 2. Creating a CI test</a></h2>
<p>Now that you've got the interface created to receive API events and create check runs, you can create a check run that implements a CI test.</p>
<p>RuboCop is a Ruby code linter and formatter. It checks Ruby code to ensure that it complies with the Ruby Style Guide. For more information, see the <a href="https://docs.rubocop.org/rubocop/index.html">RuboCop documentation</a>.</p>
<p>RuboCop has three primary functions:</p>
<ul>
<li>Linting to check code style</li>
<li>Code formatting</li>
<li>Replaces the native Ruby linting capabilities using <code>ruby -w</code>
</li>
</ul>
<p>Your app will run RuboCop on the CI server, and create check runs (CI tests in this case) that report the results that RuboCop reports to GitHub.</p>
<p>The REST API allows you to report rich details about each check run, including statuses, images, summaries, annotations, and requested actions.</p>
<p>Annotations are information about specific lines of code in a repository. An annotation allows you to pinpoint and visualize the exact parts of the code you'd like to show additional information for. For example, you could show that information as a comment, error, or warning on a specific line of code. This tutorial uses annotations to visualize RuboCop errors.</p>
<p>To take advantage of requested actions, app developers can create buttons in the <strong>Checks</strong> tab of pull requests. When someone clicks one of these buttons, the click sends a <code>requested_action</code> <code>check_run</code> event to the GitHub App. The action that the app takes is completely configurable by the app developer. This tutorial will walk you through adding a button that allows users to request that RuboCop fix the errors it finds. RuboCop supports automatically fixing errors using a command-line option, and you'll configure the <code>requested_action</code> to take advantage of this option.</p>
<p>These are the steps you'll complete in this section:</p>
<ol>
<li><a href="#step-21-add-a-ruby-file">Add a Ruby file</a></li>
<li><a href="#step-22-allow-rubocop-to-clone-the-test-repository">Allow RuboCop to clone the test repository</a></li>
<li><a href="#step-23-run-rubocop">Run RuboCop</a></li>
<li><a href="#step-24-collect-rubocop-errors">Collect RuboCop errors</a></li>
<li><a href="#step-25-update-the-check-run-with-ci-test-results">Update the check run with CI test results</a></li>
<li><a href="#step-26-automatically-fix-rubocop-errors">Automatically fix RuboCop errors</a></li>
</ol>
<h2><a href="#step-21-add-a-ruby-file">Step 2.1. Add a Ruby file</a></h2>
<p>You can pass specific files or entire directories for RuboCop to check. In this tutorial, you'll run RuboCop on an entire directory. RuboCop only checks Ruby code. To test your GitHub App, you'll need to add a Ruby file in your repository that contains errors for RuboCop to find. After adding the following Ruby file to your repository, you will update your CI check to run RuboCop on the code.</p>
<ol>
<li>
<p>Navigate to the test repository you created in <a href="#test-that-the-server-is-listening-to-your-app">Test that the server is listening to your app</a>. This is the repository that you granted the app access to.</p>
</li>
<li>
<p>Create a new file named <code>myfile.rb</code>. For more information, see <a href="/en/repositories/working-with-files/managing-files/creating-new-files">Creating new files</a>.</p>
</li>
<li>
<p>Add the following content to <code>myfile.rb</code>:</p>
<div>
<header><span>Ruby</span><pre># frozen_string_literal: true

# The Octocat class tells you about different breeds of Octocat
class Octocat
  def initialize(name, *breeds)
    # Instance variables
    @name = name
    @breeds = breeds
  end

  def display
    breed = @breeds.join("-")

    puts "I am of #{breed} breed, and my name is #{@name}."
  end
end

m = Octocat.new("Mona", "cat", "octopus")
m.display
</pre></header><pre><code><span># frozen_string_literal: true</span>

<span># The Octocat class tells you about different breeds of Octocat</span>
<span>class</span> <span>Octocat</span>
  <span>def</span> <span>initialize</span>(<span>name, *breeds</span>)
    <span># Instance variables</span>
    <span>@name</span> = name
    <span>@breeds</span> = breeds
  <span>end</span>

  <span>def</span> <span>display</span>
    breed = <span>@breeds</span>.join(<span>"-"</span>)

    puts <span>"I am of <span>#{breed}</span> breed, and my name is <span>#{<span>@name</span>}</span>."</span>
  <span>end</span>
<span>end</span>

m = <span>Octocat</span>.new(<span>"Mona"</span>, <span>"cat"</span>, <span>"octopus"</span>)
m.display
</code></pre>
</div>
</li>
<li>
<p>If you created the file locally, make sure you commit and push the file to your repository on GitHub.</p>
</li>
</ol>
<h2><a href="#step-22-allow-rubocop-to-clone-the-test-repository">Step 2.2. Allow RuboCop to clone the test repository</a></h2>
<p>RuboCop is available as a command-line utility. That means, if you want to run RuboCop on a repository, your GitHub App will need to clone a local copy of the repository on the CI server so RuboCop can parse the files. To do that, your code will need to be able to run Git operations, and your GitHub App will need to have the correct permissions to clone a repository.</p>
<h3><a href="#allow-git-operations">Allow Git operations</a></h3>
<p>To run Git operations in your Ruby app, you can use the <a href="https://github.com/ruby-git/ruby-git">ruby-git</a> gem. The <code>Gemfile</code> you created in <a href="#setup">Setup</a> already includes the ruby-git gem, and you installed it when you ran <code>bundle install</code> in <a href="#start-the-server">Start the server</a>.</p>
<p>Now, at the top of your <code>server.rb</code> file, below the other <code>require</code> items, add the following code:</p>
<div>
<header><span>Ruby</span><pre>require 'git'
</pre></header><pre><code><span>require</span> <span>'git'</span>
</code></pre>
</div>
<h3><a href="#update-your-app-permissions">Update your app permissions</a></h3>
<p>Next you'll need to update your GitHub App's permissions. Your app will need read permission for "Contents" to clone a repository. And later in this tutorial, it will need write permission to push contents to GitHub. To update your app's permissions:</p>
<ol>
<li>Select your app from the <a href="https://github.com/settings/apps">app settings page</a>, and click <strong>Permissions &amp; events</strong> in the sidebar.</li>
<li>Under "Repository permissions", next to "Contents", select <strong>Read &amp; write</strong>.</li>
<li>Click <strong>Save changes</strong> at the bottom of the page.</li>
<li>If you've installed the app on your account, check your email and follow the link to accept the new permissions. Any time you change your app's permissions or webhooks, users who have installed the app (including yourself) will need to accept the new permissions before the changes take effect. You can also accept the new permissions by navigating to your <a href="https://github.com/settings/installations">installations page</a>. You'll see a link under the app name, letting you know that the app is requesting different permissions. Click <strong>Review request</strong>, and then click <strong>Accept new permissions</strong>.</li>
</ol>
<h3><a href="#add-code-to-clone-a-repository">Add code to clone a repository</a></h3>
<p>To clone a repository, the code will use your GitHub App's permissions and the Octokit SDK to create an installation token for your app (<code>x-access-token:TOKEN</code>) and use it in the following clone command:</p>
<pre><code>git clone https://x-access-token:TOKEN@github.com/OWNER/REPO.git
</code></pre>
<p>The command above clones a repository over HTTPS. It requires the full repository name, which includes the repository owner (user or organization) and the repository name. For example, the <a href="https://github.com/octocat/Hello-World">octocat Hello-World</a> repository has a full name of <code>octocat/hello-world</code>.</p>
<p>Open your <code>server.rb</code> file. In the code block that starts with <code>helpers do</code>, where it says <code># ADD CLONE_REPOSITORY HELPER METHOD HERE #</code>, add the following code:</p>
<div>
<header><span>Ruby</span><pre>    # Clones the repository to the current working directory, updates the
    # contents using Git pull, and checks out the ref.
    #
    # full_repo_name  - The owner and repo. Ex: octocat/hello-world
    # repository      - The repository name
    # ref             - The branch, commit SHA, or tag to check out
    def clone_repository(full_repo_name, repository, ref)
      @git = Git.clone("https://x-access-token:#{@installation_token.to_s}@github.com/#{full_repo_name}.git", repository)
      pwd = Dir.getwd()
      Dir.chdir(repository)
      @git.pull
      @git.checkout(ref)
      Dir.chdir(pwd)
    end
</pre></header><pre><code>    <span># Clones the repository to the current working directory, updates the</span>
    <span># contents using Git pull, and checks out the ref.</span>
    <span>#</span>
    <span># full_repo_name  - The owner and repo. Ex: octocat/hello-world</span>
    <span># repository      - The repository name</span>
    <span># ref             - The branch, commit SHA, or tag to check out</span>
    <span>def</span> <span>clone_repository</span>(<span>full_repo_name, repository, ref</span>)
      <span>@git</span> = <span>Git</span>.clone(<span>"https://x-access-token:<span>#{<span>@installation_token</span>.to_s}</span>@github.com/<span>#{full_repo_name}</span>.git"</span>, repository)
      pwd = <span>Dir</span>.getwd()
      <span>Dir</span>.chdir(repository)
      <span>@git</span>.pull
      <span>@git</span>.checkout(ref)
      <span>Dir</span>.chdir(pwd)
    <span>end</span>
</code></pre>
</div>
<p>The code above uses the <code>ruby-git</code> gem to clone the repository using the app's installation token. It clones the code in the same directory as <code>server.rb</code>. To run Git commands in the repository, the code needs to change into the repository directory. Before changing directories, the code stores the current working directory in a variable (<code>pwd</code>) to remember where to return before exiting the <code>clone_repository</code> method.</p>
<p>From the repository directory, this code fetches and merges the latest changes (<code>@git.pull</code>), and checks out the specific Git ref (<code>@git.checkout(ref)</code>). The code to do all of this fits nicely into its own method. To perform these operations, the method needs the name and full name of the repository and the ref to checkout. The ref can be a commit SHA, branch, or tag. When it's done, the code changes the directory back to the original working directory (<code>pwd</code>).</p>
<p>Now you've got a method that clones a repository and checks out a ref. Next, you need to add code to get the required input parameters and call the new <code>clone_repository</code> method.</p>
<p>In the code block that starts with <code>helpers do</code>, in the <code>initiate_check_run</code> helper method where it says <code># ***** RUN A CI TEST *****</code>, add the following code:</p>
<div>
<header><span>Ruby</span><pre>    full_repo_name = @payload['repository']['full_name']
    repository     = @payload['repository']['name']
    head_sha       = @payload['check_run']['head_sha']

    clone_repository(full_repo_name, repository, head_sha)

    # ADD CODE HERE TO RUN RUBOCOP #
</pre></header><pre><code>    full_repo_name = <span>@payload</span>[<span>'repository'</span>][<span>'full_name'</span>]
    repository     = <span>@payload</span>[<span>'repository'</span>][<span>'name'</span>]
    head_sha       = <span>@payload</span>[<span>'check_run'</span>][<span>'head_sha'</span>]

    clone_repository(full_repo_name, repository, head_sha)

    <span># ADD CODE HERE TO RUN RUBOCOP #</span>
</code></pre>
</div>
<p>The code above gets the full repository name and the head SHA of the commit from the <code>check_run</code> webhook payload.</p>
<h2><a href="#step-23-run-rubocop">Step 2.3. Run RuboCop</a></h2>
<p>So far, your code clones the repository and creates check runs using your CI server. Now you'll get into the details of the <a href="https://docs.rubocop.org/rubocop/usage/basic_usage.html#code-style-checker">RuboCop linter</a> and <a href="/en/rest/checks/runs#create-a-check-run">checks annotations</a>.</p>
<p>First, you'll add code to run RuboCop and save the style code errors in JSON format.</p>
<p>In the code block that starts with <code>helpers do</code>, find the <code>initiate_check_run</code> helper method. Inside that helper method, under <code>clone_repository(full_repo_name, repository, head_sha)</code>, where it says <code># ADD CODE HERE TO RUN RUBOCOP #</code>, add the following code:</p>
<div>
<header><span>Ruby</span><pre>        # Run RuboCop on all files in the repository
        @report = `rubocop '#{repository}' --format json`
        logger.debug @report
        `rm -rf #{repository}`
        @output = JSON.parse @report

        # ADD ANNOTATIONS CODE HERE #
</pre></header><pre><code>        <span># Run RuboCop on all files in the repository</span>
        <span>@report</span> = <span>`rubocop '<span>#{repository}</span>' --format json`</span>
        logger.debug <span>@report</span>
        <span>`rm -rf <span>#{repository}</span>`</span>
        <span>@output</span> = <span>JSON</span>.parse <span>@report</span>

        <span># ADD ANNOTATIONS CODE HERE #</span>
</code></pre>
</div>
<p>The code above runs RuboCop on all files in the repository's directory. The option <code>--format json</code> saves a copy of the linting results in a machine-parsable format. For more information, and an example of the JSON format, see <a href="https://docs.rubocop.org/rubocop/formatters.html#json-formatter">JSON Formatter</a> in the RuboCop docs. This code also parses the JSON so you can easily access the keys and values in your GitHub App using the <code>@output</code> variable.</p>
<p>After running RuboCop and saving the linting results, this code runs the command <code>rm -rf</code> to remove the checkout of the repository. Because the code stores the RuboCop results in a <code>@report</code> variable, it can safely remove the checkout of the repository.</p>
<p>The <code>rm -rf</code> command cannot be undone. To keep your app secure, the code in this tutorial checks incoming webhooks for injected malicious commands that could be used to remove a different directory than intended by your app. For example, if a bad actor sent a webhook with the repository name <code>./</code>, your app would remove the root directory. The <code>verify_webhook_signature</code> method validates the sender of the webhook. The <code>verify_webhook_signature</code> event handler also checks that the repository name is valid. For more information, see <a href="#define-a-before-filter">Define a <code>before</code> filter</a>.</p>
<h3><a href="#test-the-code-2">Test the code</a></h3>
<p>The following steps will show you how to test that the code works and view the errors reported by RuboCop.</p>
<ol>
<li>
<p>Run the following command to restart the server from your terminal. If the server is already running, first enter <code>Ctrl-C</code> in your terminal to stop the server, and then run the following command to start the server again.</p>
<div>
<header><span>Shell</span><pre>ruby server.rb
</pre></header><pre><code>ruby server.rb
</code></pre>
</div>
</li>
<li>
<p>In the repository where you added the <code>myfile.rb</code> file, create a new pull request.</p>
</li>
<li>
<p>In your terminal tab where the server is running, you should see debug output that contains linting errors. The linting errors are printed without any formatting. You can copy and paste your debug output into a web tool like <a href="https://jsonformatter.org/">JSON formatter</a>, to format your JSON output like the following example:</p>
<pre><code><span>{</span>
  <span>"metadata"</span><span>:</span> <span>{</span>
    <span>"rubocop_version"</span><span>:</span> <span>"0.60.0"</span><span>,</span>
    <span>"ruby_engine"</span><span>:</span> <span>"ruby"</span><span>,</span>
    <span>"ruby_version"</span><span>:</span> <span>"2.3.7"</span><span>,</span>
    <span>"ruby_patchlevel"</span><span>:</span> <span>"456"</span><span>,</span>
    <span>"ruby_platform"</span><span>:</span> <span>"universal.x86_64-darwin18"</span>
  <span>}</span><span>,</span>
  <span>"files"</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>"path"</span><span>:</span> <span>"Octocat-breeds/octocat.rb"</span><span>,</span>
      <span>"offenses"</span><span>:</span> <span>[</span>
        <span>{</span>
          <span>"severity"</span><span>:</span> <span>"convention"</span><span>,</span>
          <span>"message"</span><span>:</span> <span>"Style/StringLiterals: Prefer single-quoted strings when you don't need string interpolation or special symbols."</span><span>,</span>
          <span>"cop_name"</span><span>:</span> <span>"Style/StringLiterals"</span><span>,</span>
          <span>"corrected"</span><span>:</span> <span><span>false</span></span><span>,</span>
          <span>"location"</span><span>:</span> <span>{</span>
            <span>"start_line"</span><span>:</span> <span>17</span><span>,</span>
            <span>"start_column"</span><span>:</span> <span>17</span><span>,</span>
            <span>"last_line"</span><span>:</span> <span>17</span><span>,</span>
            <span>"last_column"</span><span>:</span> <span>22</span><span>,</span>
            <span>"length"</span><span>:</span> <span>6</span><span>,</span>
            <span>"line"</span><span>:</span> <span>17</span><span>,</span>
            <span>"column"</span><span>:</span> <span>17</span>
          <span>}</span>
        <span>}</span><span>,</span>
        <span>{</span>
          <span>"severity"</span><span>:</span> <span>"convention"</span><span>,</span>
          <span>"message"</span><span>:</span> <span>"Style/StringLiterals: Prefer single-quoted strings when you don't need string interpolation or special symbols."</span><span>,</span>
          <span>"cop_name"</span><span>:</span> <span>"Style/StringLiterals"</span><span>,</span>
          <span>"corrected"</span><span>:</span> <span><span>false</span></span><span>,</span>
          <span>"location"</span><span>:</span> <span>{</span>
            <span>"start_line"</span><span>:</span> <span>17</span><span>,</span>
            <span>"start_column"</span><span>:</span> <span>25</span><span>,</span>
            <span>"last_line"</span><span>:</span> <span>17</span><span>,</span>
            <span>"last_column"</span><span>:</span> <span>29</span><span>,</span>
            <span>"length"</span><span>:</span> <span>5</span><span>,</span>
            <span>"line"</span><span>:</span> <span>17</span><span>,</span>
            <span>"column"</span><span>:</span> <span>25</span>
          <span>}</span>
        <span>}</span>
      <span>]</span>
    <span>}</span>
  <span>]</span><span>,</span>
  <span>"summary"</span><span>:</span> <span>{</span>
    <span>"offense_count"</span><span>:</span> <span>2</span><span>,</span>
    <span>"target_file_count"</span><span>:</span> <span>1</span><span>,</span>
    <span>"inspected_file_count"</span><span>:</span> <span>1</span>
  <span>}</span>
<span>}</span>
</code></pre>
</li>
</ol>
<h2><a href="#step-24-collect-rubocop-errors">Step 2.4. Collect RuboCop errors</a></h2>
<p>The <code>@output</code> variable contains the parsed JSON results of the RuboCop report. As shown in the example output in the previous step, the results contain a <code>summary</code> section that your code can use to quickly determine if there are any errors. The following code will set the check run conclusion to <code>success</code> when there are no reported errors. RuboCop reports errors for each file in the <code>files</code> array, so if there are errors, you'll need to extract some data from the file object.</p>
<p>The REST API endpoints to manage check runs allow you to create annotations for specific lines of code. When you create or update a check run, you can add annotations. In this tutorial you will update the check run with annotations, using the <code>PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}</code> endpoint. For more information about the endpoint, see <a href="/en/rest/checks/runs#update-a-check-run">REST API endpoints for check runs</a>.</p>
<p>The API limits the number of annotations to a maximum of 50 per request. To create more than 50 annotations, you will have to make multiple requests to the "Update a check run" endpoint. For example, to create 105 annotations you would need to make three separate requests to the API. The first two requests would each have 50 annotations, and the third request would include the five remaining annotations. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run.</p>
<p>A check run expects annotations as an array of objects. Each annotation object must include the <code>path</code>, <code>start_line</code>, <code>end_line</code>, <code>annotation_level</code>, and <code>message</code>. RuboCop provides the <code>start_column</code> and <code>end_column</code> too, so you can include those optional parameters in the annotation. Annotations only support <code>start_column</code> and <code>end_column</code> on the same line. For more information, see the <code>annotations</code> object in <a href="/en/rest/checks/runs#create-a-check-run">REST API endpoints for check runs</a>.</p>
<p>Now you'll add code to extract the required information from RuboCop that's needed to create each annotation.</p>
<p>Under the code you added in the previous step, where it says <code># ADD ANNOTATIONS CODE HERE #</code>, add the following code:</p>
<div>
<header><span>Ruby</span><pre>    annotations = []
    # You can create a maximum of 50 annotations per request to the Checks
    # API. To add more than 50 annotations, use the "Update a check run" API
    # endpoint. This example code limits the number of annotations to 50.
    # See /rest/reference/checks#update-a-check-run
    # for details.
    max_annotations = 50

    # RuboCop reports the number of errors found in "offense_count"
    if @output['summary']['offense_count'] == 0
      conclusion = 'success'
    else
      conclusion = 'neutral'
      @output['files'].each do |file|

        # Only parse offenses for files in this app's repository
        file_path = file['path'].gsub(/#{repository}\//,'')
        annotation_level = 'notice'

        # Parse each offense to get details and location
        file['offenses'].each do |offense|
          # Limit the number of annotations to 50
          next if max_annotations == 0
          max_annotations -= 1

          start_line   = offense['location']['start_line']
          end_line     = offense['location']['last_line']
          start_column = offense['location']['start_column']
          end_column   = offense['location']['last_column']
          message      = offense['message']

          # Create a new annotation for each error
          annotation = {
            path: file_path,
            start_line: start_line,
            end_line: end_line,
            start_column: start_column,
            end_column: end_column,
            annotation_level: annotation_level,
            message: message
          }
          # Annotations only support start and end columns on the same line
          if start_line == end_line
            annotation.merge({start_column: start_column, end_column: end_column})
          end

          annotations.push(annotation)
        end
      end
    end

    # ADD CODE HERE TO UPDATE CHECK RUN SUMMARY #
</pre></header><pre><code>    annotations = []
    <span># You can create a maximum of 50 annotations per request to the Checks</span>
    <span># API. To add more than 50 annotations, use the "Update a check run" API</span>
    <span># endpoint. This example code limits the number of annotations to 50.</span>
    <span># See /rest/reference/checks#update-a-check-run</span>
    <span># for details.</span>
    max_annotations = <span>50</span>

    <span># RuboCop reports the number of errors found in "offense_count"</span>
    <span>if</span> <span>@output</span>[<span>'summary'</span>][<span>'offense_count'</span>] == <span>0</span>
      conclusion = <span>'success'</span>
    <span>else</span>
      conclusion = <span>'neutral'</span>
      <span>@output</span>[<span>'files'</span>].each <span>do</span> |<span>file</span>|

        <span># Only parse offenses for files in this app's repository</span>
        file_path = file[<span>'path'</span>].gsub(<span>/<span>#{repository}</span>\//</span>,<span>''</span>)
        annotation_level = <span>'notice'</span>

        <span># Parse each offense to get details and location</span>
        file[<span>'offenses'</span>].each <span>do</span> |<span>offense</span>|
          <span># Limit the number of annotations to 50</span>
          <span>next</span> <span>if</span> max_annotations == <span>0</span>
          max_annotations -= <span>1</span>

          start_line   = offense[<span>'location'</span>][<span>'start_line'</span>]
          end_line     = offense[<span>'location'</span>][<span>'last_line'</span>]
          start_column = offense[<span>'location'</span>][<span>'start_column'</span>]
          end_column   = offense[<span>'location'</span>][<span>'last_column'</span>]
          message      = offense[<span>'message'</span>]

          <span># Create a new annotation for each error</span>
          annotation = {
            <span>path:</span> file_path,
            <span>start_line:</span> start_line,
            <span>end_line:</span> end_line,
            <span>start_column:</span> start_column,
            <span>end_column:</span> end_column,
            <span>annotation_level:</span> annotation_level,
            <span>message:</span> message
          }
          <span># Annotations only support start and end columns on the same line</span>
          <span>if</span> start_line == end_line
            annotation.merge({<span>start_column:</span> start_column, <span>end_column:</span> end_column})
          <span>end</span>

          annotations.push(annotation)
        <span>end</span>
      <span>end</span>
    <span>end</span>

    <span># ADD CODE HERE TO UPDATE CHECK RUN SUMMARY #</span>
</code></pre>
</div>
<p>This code limits the total number of annotations to 50. But you can modify this code to update the check run for each batch of 50 annotations. The code above includes the variable <code>max_annotations</code> that sets the limit to 50, which is used in the loop that iterates through the offenses.</p>
<p>When the <code>offense_count</code> is zero, the CI test is a <code>success</code>. If there are errors, this code sets the conclusion to <code>neutral</code> in order to prevent strictly enforcing errors from code linters. But you can change the conclusion to <code>failure</code> if you would like to ensure that the check suite fails when there are linting errors.</p>
<p>When errors are reported, the code above iterates through the <code>files</code> array in the RuboCop report. For each file, it extracts the file path and sets the annotation level to <code>notice</code>. You could go even further and set specific warning levels for each type of <a href="https://docs.rubocop.org/rubocop/cops.html">RuboCop Cop</a>, but to keep things simpler in this tutorial, all errors are set to a level of <code>notice</code>.</p>
<p>This code also iterates through each error in the <code>offenses</code> array and collects the location of the offense and error message. After extracting the information needed, the code creates an annotation for each error and stores it in the <code>annotations</code> array. Because annotations only support start and end columns on the same line, <code>start_column</code> and <code>end_column</code> are only added to the <code>annotation</code> object if the start and end line values are the same.</p>
<p>This code doesn't yet create an annotation for the check run. You'll add that code in the next section.</p>
<h2><a href="#step-25-update-the-check-run-with-ci-test-results">Step 2.5. Update the check run with CI test results</a></h2>
<p>Each check run from GitHub contains an <code>output</code> object that includes a <code>title</code>, <code>summary</code>, <code>text</code>, <code>annotations</code>, and <code>images</code>. The <code>summary</code> and <code>title</code> are the only required parameters for the <code>output</code>, but those alone don't offer much detail, so this tutorial also adds <code>text</code> and <code>annotations</code>.</p>
<p>For the <code>summary</code>, this example uses the summary information from RuboCop and adds newlines (<code>\n</code>) to format the output. You can customize what you add to the <code>text</code> parameter, but this example sets the <code>text</code> parameter to the RuboCop version. The following code sets the <code>summary</code> and <code>text</code>.</p>
<p>Under the code you added in the previous step, where it says <code># ADD CODE HERE TO UPDATE CHECK RUN SUMMARY #</code>, add the following code:</p>
<div>
<header><span>Ruby</span><pre>        # Updated check run summary and text parameters
        summary = "Octo RuboCop summary\n-Offense count: #{@output['summary']['offense_count']}\n-File count: #{@output['summary']['target_file_count']}\n-Target file count: #{@output['summary']['inspected_file_count']}"
        text = "Octo RuboCop version: #{@output['metadata']['rubocop_version']}"
</pre></header><pre><code>        <span># Updated check run summary and text parameters</span>
        summary = <span>"Octo RuboCop summary\n-Offense count: <span>#{<span>@output</span>[<span>'summary'</span>][<span>'offense_count'</span>]}</span>\n-File count: <span>#{<span>@output</span>[<span>'summary'</span>][<span>'target_file_count'</span>]}</span>\n-Target file count: <span>#{<span>@output</span>[<span>'summary'</span>][<span>'inspected_file_count'</span>]}</span>"</span>
        text = <span>"Octo RuboCop version: <span>#{<span>@output</span>[<span>'metadata'</span>][<span>'rubocop_version'</span>]}</span>"</span>
</code></pre>
</div>
<p>Now your code should have all the information it needs to update your check run. In <a href="#step-13-update-a-check-run">Step 1.3. Update a check run</a>, you added code to set the status of the check run to <code>success</code>. You'll need to update that code to use the <code>conclusion</code> variable you set based on the RuboCop results (to <code>success</code> or <code>neutral</code>). Here's the code you added previously to your <code>server.rb</code> file:</p>
<pre><code><span># Mark the check run as complete!</span>
<span>@installation_client</span>.update_check_run(
  <span>@payload</span>[<span>'repository'</span>][<span>'full_name'</span>],
  <span>@payload</span>[<span>'check_run'</span>][<span>'id'</span>],
  <span>status:</span> <span>'completed'</span>,
  <span>conclusion:</span> <span>'success'</span>,
  <span>accept:</span> <span>'application/vnd.github+json'</span>
)
</code></pre>
<p>Replace that code with the following code:</p>
<div>
<header><span>Ruby</span><pre>        # Mark the check run as complete! And if there are warnings, share them.
        @installation_client.update_check_run(
          @payload['repository']['full_name'],
          @payload['check_run']['id'],
          status: 'completed',
          conclusion: conclusion,
          output: {
            title: 'Octo RuboCop',
            summary: summary,
            text: text,
            annotations: annotations
          },
          actions: [{
            label: 'Fix this',
            description: 'Automatically fix all linter notices.',
            identifier: 'fix_rubocop_notices'
          }],
          accept: 'application/vnd.github+json'
        )
</pre></header><pre><code>        <span># Mark the check run as complete! And if there are warnings, share them.</span>
        <span>@installation_client</span>.update_check_run(
          <span>@payload</span>[<span>'repository'</span>][<span>'full_name'</span>],
          <span>@payload</span>[<span>'check_run'</span>][<span>'id'</span>],
          <span>status:</span> <span>'completed'</span>,
          <span>conclusion:</span> conclusion,
          <span>output:</span> {
            <span>title:</span> <span>'Octo RuboCop'</span>,
            <span>summary:</span> summary,
            <span>text:</span> text,
            <span>annotations:</span> annotations
          },
          <span>actions:</span> [{
            <span>label:</span> <span>'Fix this'</span>,
            <span>description:</span> <span>'Automatically fix all linter notices.'</span>,
            <span>identifier:</span> <span>'fix_rubocop_notices'</span>
          }],
          <span>accept:</span> <span>'application/vnd.github+json'</span>
        )
</code></pre>
</div>
<p>Now that your code sets a conclusion based on the status of the CI test, and adds the output from the RuboCop results, you've created a CI test.</p>
<p>The code above also adds a feature called requested actions to your CI server, via the <code>actions</code> object. (Note this is not related to <a href="/en/actions">GitHub Actions</a>.) For more information, see <a href="https://developer.github.com/changes/2018-05-23-request-actions-on-checks/">Request further actions from a check run</a>. Requested actions add a button in the <strong>Checks</strong> tab on GitHub that allows someone to request the check run to take additional action. The additional action is completely configurable by your app. For example, because RuboCop has a feature to automatically fix the errors it finds in Ruby code, your CI server can use a requested actions button to allow people to request automatic error fixes. When someone clicks the button, the app receives the <code>check_run</code> event with a <code>requested_action</code> action. Each requested action has an <code>identifier</code> that the app uses to determine which button was clicked.</p>
<p>The code above doesn't have RuboCop automatically fix errors yet. You'll add that later in the tutorial.</p>
<h3><a href="#test-the-code-3">Test the code</a></h3>
<p>The following steps will show you how to test that the code works and view the CI test that you just created.</p>
<ol>
<li>
<p>Run the following command to restart the server from your terminal. If the server is already running, first enter <code>Ctrl-C</code> in your terminal to stop the server, and then run the following command to start the server again.</p>
<div>
<header><span>Shell</span><pre>ruby server.rb
</pre></header><pre><code>ruby server.rb
</code></pre>
</div>
</li>
<li>
<p>In the repository where you added the <code>myfile.rb</code> file, create a new pull request.</p>
</li>
<li>
<p>In the pull request you just created, navigate to the <strong>Checks</strong> tab. You should see annotations for each of the errors that RuboCop found. Also notice the "Fix this" button that you created by adding a requested action.</p>
</li>
</ol>
<h2><a href="#step-26-automatically-fix-rubocop-errors">Step 2.6. Automatically fix RuboCop errors</a></h2>
<p>So far you've created a CI test. In this section, you'll add one more feature that uses RuboCop to automatically fix the errors it finds. You already added the "Fix this" button in <a href="#step-25-update-the-check-run-with-ci-test-results">Step 2.5. Update the check run with CI test results</a>. Now you'll add the code to handle the <code>requested_action</code> check run event that's triggered when someone clicks the "Fix this" button.</p>
<p>The RuboCop tool offers the <code>--auto-correct</code> command-line option to automatically fix the errors it finds. For more information, see <a href="https://docs.rubocop.org/rubocop/usage/basic_usage.html#autocorrecting-offenses">Autocorrecting offenses</a> in the RuboCop documentation. When you use the <code>--auto-correct</code> feature, the updates are applied to the local files on the server. You'll need to push the changes to GitHub after RuboCop makes the fixes.</p>
<p>To push to a repository, your app must have write permissions for "Contents" in a repository. You already set that permission to <strong>Read &amp; write</strong> back in <a href="#step-22-allow-rubocop-to-clone-the-test-repository">Step 2.2. Allow RuboCop to clone the test repository</a>.</p>
<p>To commit files, Git must know which username and email address to associate with the commit. Next you'll add environment variables to store the name and email address that your app will use when it makes Git commits.</p>
<ol>
<li>
<p>Open the <code>.env</code> file you created earlier in this tutorial.</p>
</li>
<li>
<p>Add the following environment variables to your <code>.env</code> file. Replace <code>APP_NAME</code> with the name of your app, and <code>EMAIL_ADDRESS</code> with any email you'd like to use for this example.</p>
<div>
<header><span>Shell</span><pre>GITHUB_APP_USER_NAME="APP_NAME"
GITHUB_APP_USER_EMAIL="EMAIL_ADDRESS"
</pre></header><pre><code>GITHUB_APP_USER_NAME="APP_NAME"
GITHUB_APP_USER_EMAIL="EMAIL_ADDRESS"
</code></pre>
</div>
</li>
</ol>
<p>Next you'll need to add code to read the environment variables and set the Git configuration. You'll add that code soon.</p>
<p>When someone clicks the "Fix this" button, your app receives the <a href="/en/webhooks-and-events/webhooks/webhook-events-and-payloads#check_run">check run webhook</a> with the <code>requested_action</code> action type.</p>
<p>In <a href="#step-13-update-a-check-run">Step 1.3. Update a check run</a> you updated the <code>event_handler</code> in your <code>server.rb</code> file to look for actions in the <code>check_run</code> event. You already have a case statement to handle the <code>created</code> and <code>rerequested</code> action types:</p>
<pre><code><span>when</span> <span>'check_run'</span>
  <span># Check that the event is being sent to this app</span>
  <span>if</span> <span>@payload</span>[<span>'check_run'</span>][<span>'app'</span>][<span>'id'</span>].to_s === <span>APP_IDENTIFIER</span>
    <span>case</span> <span>@payload</span>[<span>'action'</span>]
    <span>when</span> <span>'created'</span>
      initiate_check_run
    <span>when</span> <span>'rerequested'</span>
      create_check_run
    <span># ADD REQUESTED_ACTION METHOD HERE #</span>
  <span>end</span>
<span>end</span>
</code></pre>
<p>After the <code>rerequested</code> case, where it says <code># ADD REQUESTED_ACTION METHOD HERE #</code>, add the following code:</p>
<div>
<header><span>Ruby</span><pre>    when 'requested_action'
      take_requested_action
</pre></header><pre><code>    <span>when</span> <span>'requested_action'</span>
      take_requested_action
</code></pre>
</div>
<p>This code calls a new method that will handle all <code>requested_action</code> events for your app.</p>
<p>In the code block that starts with <code>helpers do</code>, where it says <code># ADD TAKE_REQUESTED_ACTION HELPER METHOD HERE #</code>, add the following helper method:</p>
<div>
<header><span>Ruby</span><pre>    # Handles the check run `requested_action` event
    # See /webhooks/event-payloads/#check_run
    def take_requested_action
      full_repo_name = @payload['repository']['full_name']
      repository     = @payload['repository']['name']
      head_branch    = @payload['check_run']['check_suite']['head_branch']

      if (@payload['requested_action']['identifier'] == 'fix_rubocop_notices')
        clone_repository(full_repo_name, repository, head_branch)

        # Sets your commit username and email address
        @git.config('user.name', ENV['GITHUB_APP_USER_NAME'])
        @git.config('user.email', ENV['GITHUB_APP_USER_EMAIL'])

        # Automatically correct RuboCop style errors
        @report = `rubocop '#{repository}/*' --format json --auto-correct`

        pwd = Dir.getwd()
        Dir.chdir(repository)
        begin
          @git.commit_all('Automatically fix Octo RuboCop notices.')
          @git.push("https://x-access-token:#{@installation_token.to_s}@github.com/#{full_repo_name}.git", head_branch)
        rescue
          # Nothing to commit!
          puts 'Nothing to commit'
        end
        Dir.chdir(pwd)
        `rm -rf '#{repository}'`
      end
    end
</pre></header><pre><code>    <span># Handles the check run `requested_action` event</span>
    <span># See /webhooks/event-payloads/#check_run</span>
    <span>def</span> <span>take_requested_action</span>
      full_repo_name = <span>@payload</span>[<span>'repository'</span>][<span>'full_name'</span>]
      repository     = <span>@payload</span>[<span>'repository'</span>][<span>'name'</span>]
      head_branch    = <span>@payload</span>[<span>'check_run'</span>][<span>'check_suite'</span>][<span>'head_branch'</span>]

      <span>if</span> (<span>@payload</span>[<span>'requested_action'</span>][<span>'identifier'</span>] == <span>'fix_rubocop_notices'</span>)
        clone_repository(full_repo_name, repository, head_branch)

        <span># Sets your commit username and email address</span>
        <span>@git</span>.config(<span>'user.name'</span>, <span>ENV</span>[<span>'GITHUB_APP_USER_NAME'</span>])
        <span>@git</span>.config(<span>'user.email'</span>, <span>ENV</span>[<span>'GITHUB_APP_USER_EMAIL'</span>])

        <span># Automatically correct RuboCop style errors</span>
        <span>@report</span> = <span>`rubocop '<span>#{repository}</span>/*' --format json --auto-correct`</span>

        pwd = <span>Dir</span>.getwd()
        <span>Dir</span>.chdir(repository)
        <span>begin</span>
          <span>@git</span>.commit_all(<span>'Automatically fix Octo RuboCop notices.'</span>)
          <span>@git</span>.push(<span>"https://x-access-token:<span>#{<span>@installation_token</span>.to_s}</span>@github.com/<span>#{full_repo_name}</span>.git"</span>, head_branch)
        <span>rescue</span>
          <span># Nothing to commit!</span>
          puts <span>'Nothing to commit'</span>
        <span>end</span>
        <span>Dir</span>.chdir(pwd)
        <span>`rm -rf '<span>#{repository}</span>'`</span>
      <span>end</span>
    <span>end</span>
</code></pre>
</div>
<p>The code above clones a repository, just like the code you added in <a href="#step-22-allow-rubocop-to-clone-the-test-repository">Step 2.2. Allow RuboCop to clone the test repository</a>. An <code>if</code> statement checks that the requested action's identifier matches the RuboCop button identifier (<code>fix_rubocop_notices</code>). When they match, the code clones the repository, sets the Git username and email, and runs RuboCop with the option <code>--auto-correct</code>. The <code>--auto-correct</code> option applies the changes to the local CI server files automatically.</p>
<p>The files are changed locally, but you'll still need to push them to GitHub. You'll use the <code>ruby-git</code> gem to commit all of the files. Git has a single command that stages all modified or deleted files and commits them: <code>git commit -a</code>. To do the same thing using <code>ruby-git</code>, the code above uses the <code>commit_all</code> method. Then the code pushes the committed files to GitHub using the installation token, using the same authentication method as the Git <code>clone</code> command. Finally, it removes the repository directory to ensure the working directory is prepared for the next event.</p>
<p>The code you have written now completes your continuous integration server that you built using a GitHub App and checks. To see the full final code for your app, see <a href="#full-code-example">Full code example</a>.</p>
<h3><a href="#test-the-code-4">Test the code</a></h3>
<p>The following steps will show you how to test that the code works, and that RuboCop can automatically fix the errors it finds.</p>
<ol>
<li>
<p>Run the following command to restart the server from your terminal. If the server is already running, first enter <code>Ctrl-C</code> in your terminal to stop the server, and then run the following command to start the server again.</p>
<div>
<header><span>Shell</span><pre>ruby server.rb
</pre></header><pre><code>ruby server.rb
</code></pre>
</div>
</li>
<li>
<p>In the repository where you added the <code>myfile.rb</code> file, create a new pull request.</p>
</li>
<li>
<p>In the new pull request you created, navigate to the <strong>Checks</strong> tab, and click the "Fix this" button to automatically fix the errors RuboCop found.</p>
</li>
<li>
<p>Navigate to the <strong>Commits</strong> tab. You should see a new commit by the username you set in your Git configuration. You may need to refresh your browser to see the update.</p>
</li>
<li>
<p>Navigate to the <strong>Checks</strong> tab. You should see a new check suite for Octo RuboCop. But this time there should be no errors, because RuboCop fixed them all.</p>
</li>
</ol>
<h2><a href="#full-code-example">Full code example</a></h2>
<p>This is what the final code in <code>server.rb</code> should look like, after you've followed all of the steps in this tutorial. There are also comments throughout the code that provide additional context.</p>
<div>
<header><span>Ruby</span><pre>require 'sinatra/base'  # Use the Sinatra web framework
require 'octokit'       # Use the Octokit Ruby library to interact with GitHub's REST API
require 'dotenv/load'   # Manages environment variables
require 'json'          # Allows your app to manipulate JSON data
require 'openssl'       # Verifies the webhook signature
require 'jwt'           # Authenticates a GitHub App
require 'time'          # Gets ISO 8601 representation of a Time object
require 'logger'        # Logs debug statements

# This code is a Sinatra app, for two reasons:
#   1. Because the app will require a landing page for installation.
#   2. To easily handle webhook events.

class GHAapp &lt; Sinatra::Application

  # Sets the port that's used when starting the web server.
  set :port, 3000
  set :bind, '0.0.0.0'

  # Expects the private key in PEM format. Converts the newlines.
  PRIVATE_KEY = OpenSSL::PKey::RSA.new(ENV['GITHUB_PRIVATE_KEY'].gsub('\n', "\n"))

  # Your registered app must have a webhook secret.
  # The secret is used to verify that webhooks are sent by GitHub.
  WEBHOOK_SECRET = ENV['GITHUB_WEBHOOK_SECRET']

  # The GitHub App's identifier (type integer).
  APP_IDENTIFIER = ENV['GITHUB_APP_IDENTIFIER']

  # Turn on Sinatra's verbose logging during development
  configure :development do
    set :logging, Logger::DEBUG
  end

  # Executed before each request to the `/event_handler` route
  before '/event_handler' do
    get_payload_request(request)
    verify_webhook_signature

    # If a repository name is provided in the webhook, validate that
    # it consists only of latin alphabetic characters, `-`, and `_`.
    unless @payload['repository'].nil?
      halt 400 if (@payload['repository']['name'] =~ /[0-9A-Za-z\-\_]+/).nil?
    end

    authenticate_app
    # Authenticate the app installation in order to run API operations
    authenticate_installation(@payload)
  end

  post '/event_handler' do

    # Get the event type from the HTTP_X_GITHUB_EVENT header
    case request.env['HTTP_X_GITHUB_EVENT']

    when 'check_suite'
      # A new check_suite has been created. Create a new check run with status queued
      if @payload['action'] == 'requested' || @payload['action'] == 'rerequested'
        create_check_run
      end

    when 'check_run'
      # Check that the event is being sent to this app
      if @payload['check_run']['app']['id'].to_s === APP_IDENTIFIER
        case @payload['action']
        when 'created'
          initiate_check_run
        when 'rerequested'
          create_check_run
        when 'requested_action'
          take_requested_action
        end
      end
    end

    200 # success status
  end

  helpers do

    # Create a new check run with status "queued"
    def create_check_run
      @installation_client.create_check_run(
        # [String, Integer, Hash, Octokit Repository object] A GitHub repository.
        @payload['repository']['full_name'],
        # [String] The name of your check run.
        'Octo RuboCop',
        # [String] The SHA of the commit to check
        # The payload structure differs depending on whether a check run or a check suite event occurred.
        @payload['check_run'].nil? ? @payload['check_suite']['head_sha'] : @payload['check_run']['head_sha'],
        # [Hash] 'Accept' header option, to avoid a warning about the API not being ready for production use.
        accept: 'application/vnd.github+json'
      )
    end

    # Start the CI process
    def initiate_check_run
      # Once the check run is created, you'll update the status of the check run
      # to 'in_progress' and run the CI process. When the CI finishes, you'll
      # update the check run status to 'completed' and add the CI results.

      @installation_client.update_check_run(
        @payload['repository']['full_name'],
        @payload['check_run']['id'],
        status: 'in_progress',
        accept: 'application/vnd.github+json'
      )

      full_repo_name = @payload['repository']['full_name']
      repository     = @payload['repository']['name']
      head_sha       = @payload['check_run']['head_sha']

      clone_repository(full_repo_name, repository, head_sha)

      # Run RuboCop on all files in the repository
      @report = `rubocop '#{repository}' --format json`
      logger.debug @report
      `rm -rf #{repository}`
      @output = JSON.parse @report

      annotations = []
      # You can create a maximum of 50 annotations per request to the Checks
      # API. To add more than 50 annotations, use the "Update a check run" API
      # endpoint. This example code limits the number of annotations to 50.
      # See /rest/reference/checks#update-a-check-run
      # for details.
      max_annotations = 50

      # RuboCop reports the number of errors found in "offense_count"
      if @output['summary']['offense_count'] == 0
        conclusion = 'success'
      else
        conclusion = 'neutral'
        @output['files'].each do |file|

          # Only parse offenses for files in this app's repository
          file_path = file['path'].gsub(/#{repository}\//,'')
          annotation_level = 'notice'

          # Parse each offense to get details and location
          file['offenses'].each do |offense|
            # Limit the number of annotations to 50
            next if max_annotations == 0
            max_annotations -= 1

            start_line   = offense['location']['start_line']
            end_line     = offense['location']['last_line']
            start_column = offense['location']['start_column']
            end_column   = offense['location']['last_column']
            message      = offense['message']

            # Create a new annotation for each error
            annotation = {
              path: file_path,
              start_line: start_line,
              end_line: end_line,
              start_column: start_column,
              end_column: end_column,
              annotation_level: annotation_level,
              message: message
            }
            # Annotations only support start and end columns on the same line
            if start_line == end_line
              annotation.merge({start_column: start_column, end_column: end_column})
            end

            annotations.push(annotation)
          end
        end
      end

      # Updated check run summary and text parameters
      summary = "Octo RuboCop summary\n-Offense count: #{@output['summary']['offense_count']}\n-File count: #{@output['summary']['target_file_count']}\n-Target file count: #{@output['summary']['inspected_file_count']}"
      text = "Octo RuboCop version: #{@output['metadata']['rubocop_version']}"

      # Mark the check run as complete! And if there are warnings, share them.
      @installation_client.update_check_run(
        @payload['repository']['full_name'],
        @payload['check_run']['id'],
        status: 'completed',
        conclusion: conclusion,
        output: {
          title: 'Octo RuboCop',
          summary: summary,
          text: text,
          annotations: annotations
        },
        actions: [{
          label: 'Fix this',
          description: 'Automatically fix all linter notices.',
          identifier: 'fix_rubocop_notices'
        }],
        accept: 'application/vnd.github+json'
      )
    end

    # Clones the repository to the current working directory, updates the
    # contents using Git pull, and checks out the ref.
    #
    # full_repo_name  - The owner and repo. Ex: octocat/hello-world
    # repository      - The repository name
    # ref             - The branch, commit SHA, or tag to check out
    def clone_repository(full_repo_name, repository, ref)
      @git = Git.clone("https://x-access-token:#{@installation_token.to_s}@github.com/#{full_repo_name}.git", repository)
      pwd = Dir.getwd()
      Dir.chdir(repository)
      @git.pull
      @git.checkout(ref)
      Dir.chdir(pwd)
    end

    # Handles the check run `requested_action` event
    # See /webhooks/event-payloads/#check_run
    def take_requested_action
      full_repo_name = @payload['repository']['full_name']
      repository     = @payload['repository']['name']
      head_branch    = @payload['check_run']['check_suite']['head_branch']

      if (@payload['requested_action']['identifier'] == 'fix_rubocop_notices')
        clone_repository(full_repo_name, repository, head_branch)

        # Sets your commit username and email address
        @git.config('user.name', ENV['GITHUB_APP_USER_NAME'])
        @git.config('user.email', ENV['GITHUB_APP_USER_EMAIL'])

        # Automatically correct RuboCop style errors
        @report = `rubocop '#{repository}/*' --format json --auto-correct`

        pwd = Dir.getwd()
        Dir.chdir(repository)
        begin
          @git.commit_all('Automatically fix Octo RuboCop notices.')
          @git.push("https://x-access-token:#{@installation_token.to_s}@github.com/#{full_repo_name}.git", head_branch)
        rescue
          # Nothing to commit!
          puts 'Nothing to commit'
        end
        Dir.chdir(pwd)
        `rm -rf '#{repository}'`
      end
    end

    # Saves the raw payload and converts the payload to JSON format
    def get_payload_request(request)
      # request.body is an IO or StringIO object
      # Rewind in case someone already read it
      request.body.rewind
      # The raw text of the body is required for webhook signature verification
      @payload_raw = request.body.read
      begin
        @payload = JSON.parse @payload_raw
      rescue =&gt; e
        fail 'Invalid JSON (#{e}): #{@payload_raw}'
      end
    end

    # Instantiate an Octokit client authenticated as a GitHub App.
    # GitHub App authentication requires that you construct a
    # JWT (https://jwt.io/introduction/) signed with the app's private key,
    # so GitHub can be sure that it came from the app and not altered by
    # a malicious third party.
    def authenticate_app
      payload = {
          # The time that this JWT was issued, _i.e._ now.
          iat: Time.now.to_i,

          # JWT expiration time (10 minute maximum)
          exp: Time.now.to_i + (10 * 60),

          # Your GitHub App's identifier number
          iss: APP_IDENTIFIER
      }

      # Cryptographically sign the JWT.
      jwt = JWT.encode(payload, PRIVATE_KEY, 'RS256')

      # Create the Octokit client, using the JWT as the auth token.
      @app_client ||= Octokit::Client.new(bearer_token: jwt)
    end

    # Instantiate an Octokit client, authenticated as an installation of a
    # GitHub App, to run API operations.
    def authenticate_installation(payload)
      @installation_id = payload['installation']['id']
      @installation_token = @app_client.create_app_installation_access_token(@installation_id)[:token]
      @installation_client = Octokit::Client.new(bearer_token: @installation_token)
    end

    # Check X-Hub-Signature to confirm that this webhook was generated by
    # GitHub, and not a malicious third party.
    #
    # GitHub uses the WEBHOOK_SECRET, registered to the GitHub App, to
    # create the hash signature sent in the `X-HUB-Signature` header of each
    # webhook. This code computes the expected hash signature and compares it to
    # the signature sent in the `X-HUB-Signature` header. If they don't match,
    # this request is an attack, and you should reject it. GitHub uses the HMAC
    # hexdigest to compute the signature. The `X-HUB-Signature` looks something
    # like this: 'sha1=123456'.
    def verify_webhook_signature
      their_signature_header = request.env['HTTP_X_HUB_SIGNATURE'] || 'sha1='
      method, their_digest = their_signature_header.split('=')
      our_digest = OpenSSL::HMAC.hexdigest(method, WEBHOOK_SECRET, @payload_raw)
      halt 401 unless their_digest == our_digest

      # The X-GITHUB-EVENT header provides the name of the event.
      # The action value indicates the which action triggered the event.
      logger.debug "---- received event #{request.env['HTTP_X_GITHUB_EVENT']}"
      logger.debug "----    action #{@payload['action']}" unless @payload['action'].nil?
    end

  end

  # Finally some logic to let us run this server directly from the command line,
  # or with Rack. Don't worry too much about this code. But, for the curious:
  # $0 is the executed file
  # __FILE__ is the current file
  # If they are the same—that is, we are running this file directly, call the
  # Sinatra run method
  run! if __FILE__ == $0
end
</pre></header><pre><code><span>require</span> <span>'sinatra/base'</span>  <span># Use the Sinatra web framework</span>
<span>require</span> <span>'octokit'</span>       <span># Use the Octokit Ruby library to interact with GitHub's REST API</span>
<span>require</span> <span>'dotenv/load'</span>   <span># Manages environment variables</span>
<span>require</span> <span>'json'</span>          <span># Allows your app to manipulate JSON data</span>
<span>require</span> <span>'openssl'</span>       <span># Verifies the webhook signature</span>
<span>require</span> <span>'jwt'</span>           <span># Authenticates a GitHub App</span>
<span>require</span> <span>'time'</span>          <span># Gets ISO 8601 representation of a Time object</span>
<span>require</span> <span>'logger'</span>        <span># Logs debug statements</span>

<span># This code is a Sinatra app, for two reasons:</span>
<span>#   1. Because the app will require a landing page for installation.</span>
<span>#   2. To easily handle webhook events.</span>

<span>class</span> <span>GHAapp</span> &lt; <span>Sinatra::Application</span>

  <span># Sets the port that's used when starting the web server.</span>
  set <span>:port</span>, <span>3000</span>
  set <span>:bind</span>, <span>'0.0.0.0'</span>

  <span># Expects the private key in PEM format. Converts the newlines.</span>
  <span>PRIVATE_KEY</span> = <span>OpenSSL::PKey::RSA</span>.new(<span>ENV</span>[<span>'GITHUB_PRIVATE_KEY'</span>].gsub(<span>'\n'</span>, <span>"\n"</span>))

  <span># Your registered app must have a webhook secret.</span>
  <span># The secret is used to verify that webhooks are sent by GitHub.</span>
  <span>WEBHOOK_SECRET</span> = <span>ENV</span>[<span>'GITHUB_WEBHOOK_SECRET'</span>]

  <span># The GitHub App's identifier (type integer).</span>
  <span>APP_IDENTIFIER</span> = <span>ENV</span>[<span>'GITHUB_APP_IDENTIFIER'</span>]

  <span># Turn on Sinatra's verbose logging during development</span>
  configure <span>:development</span> <span>do</span>
    set <span>:logging</span>, <span>Logger</span><span>:</span><span>:DEBUG</span>
  <span>end</span>

  <span># Executed before each request to the `/event_handler` route</span>
  before <span>'/event_handler'</span> <span>do</span>
    get_payload_request(request)
    verify_webhook_signature

    <span># If a repository name is provided in the webhook, validate that</span>
    <span># it consists only of latin alphabetic characters, `-`, and `_`.</span>
    <span>unless</span> <span>@payload</span>[<span>'repository'</span>].<span>nil</span>?
      halt <span>400</span> <span>if</span> (<span>@payload</span>[<span>'repository'</span>][<span>'name'</span>] =~ <span>/[0-9A-Za-z\-\_]+/</span>).<span>nil</span>?
    <span>end</span>

    authenticate_app
    <span># Authenticate the app installation in order to run API operations</span>
    authenticate_installation(<span>@payload</span>)
  <span>end</span>

  post <span>'/event_handler'</span> <span>do</span>

    <span># Get the event type from the HTTP_X_GITHUB_EVENT header</span>
    <span>case</span> request.env[<span>'HTTP_X_GITHUB_EVENT'</span>]

    <span>when</span> <span>'check_suite'</span>
      <span># A new check_suite has been created. Create a new check run with status queued</span>
      <span>if</span> <span>@payload</span>[<span>'action'</span>] == <span>'requested'</span> |<span>@payload</span>[<span>'action'</span>] == <span>'rerequested'</span>
        create_check_run
      <span>end</span>

    <span>when</span> <span>'check_run'</span>
      <span># Check that the event is being sent to this app</span>
      <span>if</span> <span>@payload</span>[<span>'check_run'</span>][<span>'app'</span>][<span>'id'</span>].to_s === <span>APP_IDENTIFIER</span>
        <span>case</span> <span>@payload</span>[<span>'action'</span>]
        <span>when</span> <span>'created'</span>
          initiate_check_run
        <span>when</span> <span>'rerequested'</span>
          create_check_run
        <span>when</span> <span>'requested_action'</span>
          take_requested_action
        <span>end</span>
      <span>end</span>
    <span>end</span>

    <span>200</span> <span># success status</span>
  <span>end</span>

  helpers <span>do</span>

    <span># Create a new check run with status "queued"</span>
    <span>def</span> <span>create_check_run</span>
      <span>@installation_client</span>.create_check_run(
        <span># [String, Integer, Hash, Octokit Repository object] A GitHub repository.</span>
        <span>@payload</span>[<span>'repository'</span>][<span>'full_name'</span>],
        <span># [String] The name of your check run.</span>
        <span>'Octo RuboCop'</span>,
        <span># [String] The SHA of the commit to check</span>
        <span># The payload structure differs depending on whether a check run or a check suite event occurred.</span>
        <span>@payload</span>[<span>'check_run'</span>].<span>nil</span>? ? <span>@payload</span>[<span>'check_suite'</span>][<span>'head_sha'</span>] : <span>@payload</span>[<span>'check_run'</span>][<span>'head_sha'</span>],
        <span># [Hash] 'Accept' header option, to avoid a warning about the API not being ready for production use.</span>
        <span>accept:</span> <span>'application/vnd.github+json'</span>
      )
    <span>end</span>

    <span># Start the CI process</span>
    <span>def</span> <span>initiate_check_run</span>
      <span># Once the check run is created, you'll update the status of the check run</span>
      <span># to 'in_progress' and run the CI process. When the CI finishes, you'll</span>
      <span># update the check run status to 'completed' and add the CI results.</span>

      <span>@installation_client</span>.update_check_run(
        <span>@payload</span>[<span>'repository'</span>][<span>'full_name'</span>],
        <span>@payload</span>[<span>'check_run'</span>][<span>'id'</span>],
        <span>status:</span> <span>'in_progress'</span>,
        <span>accept:</span> <span>'application/vnd.github+json'</span>
      )

      full_repo_name = <span>@payload</span>[<span>'repository'</span>][<span>'full_name'</span>]
      repository     = <span>@payload</span>[<span>'repository'</span>][<span>'name'</span>]
      head_sha       = <span>@payload</span>[<span>'check_run'</span>][<span>'head_sha'</span>]

      clone_repository(full_repo_name, repository, head_sha)

      <span># Run RuboCop on all files in the repository</span>
      <span>@report</span> = <span>`rubocop '<span>#{repository}</span>' --format json`</span>
      logger.debug <span>@report</span>
      <span>`rm -rf <span>#{repository}</span>`</span>
      <span>@output</span> = <span>JSON</span>.parse <span>@report</span>

      annotations = []
      <span># You can create a maximum of 50 annotations per request to the Checks</span>
      <span># API. To add more than 50 annotations, use the "Update a check run" API</span>
      <span># endpoint. This example code limits the number of annotations to 50.</span>
      <span># See /rest/reference/checks#update-a-check-run</span>
      <span># for details.</span>
      max_annotations = <span>50</span>

      <span># RuboCop reports the number of errors found in "offense_count"</span>
      <span>if</span> <span>@output</span>[<span>'summary'</span>][<span>'offense_count'</span>] == <span>0</span>
        conclusion = <span>'success'</span>
      <span>else</span>
        conclusion = <span>'neutral'</span>
        <span>@output</span>[<span>'files'</span>].each <span>do</span> |<span>file</span>|

          <span># Only parse offenses for files in this app's repository</span>
          file_path = file[<span>'path'</span>].gsub(<span>/<span>#{repository}</span>\//</span>,<span>''</span>)
          annotation_level = <span>'notice'</span>

          <span># Parse each offense to get details and location</span>
          file[<span>'offenses'</span>].each <span>do</span> |<span>offense</span>|
            <span># Limit the number of annotations to 50</span>
            <span>next</span> <span>if</span> max_annotations == <span>0</span>
            max_annotations -= <span>1</span>

            start_line   = offense[<span>'location'</span>][<span>'start_line'</span>]
            end_line     = offense[<span>'location'</span>][<span>'last_line'</span>]
            start_column = offense[<span>'location'</span>][<span>'start_column'</span>]
            end_column   = offense[<span>'location'</span>][<span>'last_column'</span>]
            message      = offense[<span>'message'</span>]

            <span># Create a new annotation for each error</span>
            annotation = {
              <span>path:</span> file_path,
              <span>start_line:</span> start_line,
              <span>end_line:</span> end_line,
              <span>start_column:</span> start_column,
              <span>end_column:</span> end_column,
              <span>annotation_level:</span> annotation_level,
              <span>message:</span> message
            }
            <span># Annotations only support start and end columns on the same line</span>
            <span>if</span> start_line == end_line
              annotation.merge({<span>start_column:</span> start_column, <span>end_column:</span> end_column})
            <span>end</span>

            annotations.push(annotation)
          <span>end</span>
        <span>end</span>
      <span>end</span>

      <span># Updated check run summary and text parameters</span>
      summary = <span>"Octo RuboCop summary\n-Offense count: <span>#{<span>@output</span>[<span>'summary'</span>][<span>'offense_count'</span>]}</span>\n-File count: <span>#{<span>@output</span>[<span>'summary'</span>][<span>'target_file_count'</span>]}</span>\n-Target file count: <span>#{<span>@output</span>[<span>'summary'</span>][<span>'inspected_file_count'</span>]}</span>"</span>
      text = <span>"Octo RuboCop version: <span>#{<span>@output</span>[<span>'metadata'</span>][<span>'rubocop_version'</span>]}</span>"</span>

      <span># Mark the check run as complete! And if there are warnings, share them.</span>
      <span>@installation_client</span>.update_check_run(
        <span>@payload</span>[<span>'repository'</span>][<span>'full_name'</span>],
        <span>@payload</span>[<span>'check_run'</span>][<span>'id'</span>],
        <span>status:</span> <span>'completed'</span>,
        <span>conclusion:</span> conclusion,
        <span>output:</span> {
          <span>title:</span> <span>'Octo RuboCop'</span>,
          <span>summary:</span> summary,
          <span>text:</span> text,
          <span>annotations:</span> annotations
        },
        <span>actions:</span> [{
          <span>label:</span> <span>'Fix this'</span>,
          <span>description:</span> <span>'Automatically fix all linter notices.'</span>,
          <span>identifier:</span> <span>'fix_rubocop_notices'</span>
        }],
        <span>accept:</span> <span>'application/vnd.github+json'</span>
      )
    <span>end</span>

    <span># Clones the repository to the current working directory, updates the</span>
    <span># contents using Git pull, and checks out the ref.</span>
    <span>#</span>
    <span># full_repo_name  - The owner and repo. Ex: octocat/hello-world</span>
    <span># repository      - The repository name</span>
    <span># ref             - The branch, commit SHA, or tag to check out</span>
    <span>def</span> <span>clone_repository</span>(<span>full_repo_name, repository, ref</span>)
      <span>@git</span> = <span>Git</span>.clone(<span>"https://x-access-token:<span>#{<span>@installation_token</span>.to_s}</span>@github.com/<span>#{full_repo_name}</span>.git"</span>, repository)
      pwd = <span>Dir</span>.getwd()
      <span>Dir</span>.chdir(repository)
      <span>@git</span>.pull
      <span>@git</span>.checkout(ref)
      <span>Dir</span>.chdir(pwd)
    <span>end</span>

    <span># Handles the check run `requested_action` event</span>
    <span># See /webhooks/event-payloads/#check_run</span>
    <span>def</span> <span>take_requested_action</span>
      full_repo_name = <span>@payload</span>[<span>'repository'</span>][<span>'full_name'</span>]
      repository     = <span>@payload</span>[<span>'repository'</span>][<span>'name'</span>]
      head_branch    = <span>@payload</span>[<span>'check_run'</span>][<span>'check_suite'</span>][<span>'head_branch'</span>]

      <span>if</span> (<span>@payload</span>[<span>'requested_action'</span>][<span>'identifier'</span>] == <span>'fix_rubocop_notices'</span>)
        clone_repository(full_repo_name, repository, head_branch)

        <span># Sets your commit username and email address</span>
        <span>@git</span>.config(<span>'user.name'</span>, <span>ENV</span>[<span>'GITHUB_APP_USER_NAME'</span>])
        <span>@git</span>.config(<span>'user.email'</span>, <span>ENV</span>[<span>'GITHUB_APP_USER_EMAIL'</span>])

        <span># Automatically correct RuboCop style errors</span>
        <span>@report</span> = <span>`rubocop '<span>#{repository}</span>/*' --format json --auto-correct`</span>

        pwd = <span>Dir</span>.getwd()
        <span>Dir</span>.chdir(repository)
        <span>begin</span>
          <span>@git</span>.commit_all(<span>'Automatically fix Octo RuboCop notices.'</span>)
          <span>@git</span>.push(<span>"https://x-access-token:<span>#{<span>@installation_token</span>.to_s}</span>@github.com/<span>#{full_repo_name}</span>.git"</span>, head_branch)
        <span>rescue</span>
          <span># Nothing to commit!</span>
          puts <span>'Nothing to commit'</span>
        <span>end</span>
        <span>Dir</span>.chdir(pwd)
        <span>`rm -rf '<span>#{repository}</span>'`</span>
      <span>end</span>
    <span>end</span>

    <span># Saves the raw payload and converts the payload to JSON format</span>
    <span>def</span> <span>get_payload_request</span>(<span>request</span>)
      <span># request.body is an IO or StringIO object</span>
      <span># Rewind in case someone already read it</span>
      request.body.rewind
      <span># The raw text of the body is required for webhook signature verification</span>
      <span>@payload_raw</span> = request.body.read
      <span>begin</span>
        <span>@payload</span> = <span>JSON</span>.parse <span>@payload_raw</span>
      <span>rescue</span> =&gt; e
        fail <span>'Invalid JSON (<span>#{e}</span>): <span>#{<span>@payload_raw</span>}</span>'</span>
      <span>end</span>
    <span>end</span>

    <span># Instantiate an Octokit client authenticated as a GitHub App.</span>
    <span># GitHub App authentication requires that you construct a</span>
    <span># JWT (https://jwt.io/introduction/) signed with the app's private key,</span>
    <span># so GitHub can be sure that it came from the app and not altered by</span>
    <span># a malicious third party.</span>
    <span>def</span> <span>authenticate_app</span>
      payload = {
          <span># The time that this JWT was issued, _i.e._ now.</span>
          <span>iat:</span> <span>Time</span>.now.to_i,

          <span># JWT expiration time (10 minute maximum)</span>
          <span>exp:</span> <span>Time</span>.now.to_i + (<span>10</span> * <span>60</span>),

          <span># Your GitHub App's identifier number</span>
          <span>iss:</span> <span>APP_IDENTIFIER</span>
      }

      <span># Cryptographically sign the JWT.</span>
      jwt = <span>JWT</span>.encode(payload, <span>PRIVATE_KEY</span>, <span>'RS256'</span>)

      <span># Create the Octokit client, using the JWT as the auth token.</span>
      <span>@app_client</span> |<span>Octokit::Client</span>.new(<span>bearer_token:</span> jwt)
    <span>end</span>

    <span># Instantiate an Octokit client, authenticated as an installation of a</span>
    <span># GitHub App, to run API operations.</span>
    <span>def</span> <span>authenticate_installation</span>(<span>payload</span>)
      <span>@installation_id</span> = payload[<span>'installation'</span>][<span>'id'</span>]
      <span>@installation_token</span> = <span>@app_client</span>.create_app_installation_access_token(<span>@installation_id</span>)[<span>:token</span>]
      <span>@installation_client</span> = <span>Octokit::Client</span>.new(<span>bearer_token:</span> <span>@installation_token</span>)
    <span>end</span>

    <span># Check X-Hub-Signature to confirm that this webhook was generated by</span>
    <span># GitHub, and not a malicious third party.</span>
    <span>#</span>
    <span># GitHub uses the WEBHOOK_SECRET, registered to the GitHub App, to</span>
    <span># create the hash signature sent in the `X-HUB-Signature` header of each</span>
    <span># webhook. This code computes the expected hash signature and compares it to</span>
    <span># the signature sent in the `X-HUB-Signature` header. If they don't match,</span>
    <span># this request is an attack, and you should reject it. GitHub uses the HMAC</span>
    <span># hexdigest to compute the signature. The `X-HUB-Signature` looks something</span>
    <span># like this: 'sha1=123456'.</span>
    <span>def</span> <span>verify_webhook_signature</span>
      their_signature_header = request.env[<span>'HTTP_X_HUB_SIGNATURE'</span>] |<span>'sha1='</span>
      method, their_digest = their_signature_header.split(<span>'='</span>)
      our_digest = <span>Open</span>SSL::<span>HMAC</span>.hexdigest(method, <span>WEBHOOK_SECRET</span>, <span>@payload_raw</span>)
      halt <span>401</span> <span>unless</span> their_digest == our_digest

      <span># The X-GITHUB-EVENT header provides the name of the event.</span>
      <span># The action value indicates the which action triggered the event.</span>
      logger.debug <span>"---- received event <span>#{request.env[<span>'HTTP_X_GITHUB_EVENT'</span>]}</span>"</span>
      logger.debug <span>"----    action <span>#{<span>@payload</span>[<span>'action'</span>]}</span>"</span> <span>unless</span> <span>@payload</span>[<span>'action'</span>].<span>nil</span>?
    <span>end</span>

  <span>end</span>

  <span># Finally some logic to let us run this server directly from the command line,</span>
  <span># or with Rack. Don't worry too much about this code. But, for the curious:</span>
  <span># $0 is the executed file</span>
  <span># __FILE__ is the current file</span>
  <span># If they are the same—that is, we are running this file directly, call the</span>
  <span># Sinatra run method</span>
  run! <span>if</span> <span>__FILE__</span> == <span>$0</span>
<span>end</span>
</code></pre>
</div>
<h2><a href="#next-steps">Next steps</a></h2>
<p>You should now have an app that receives API events, creates check runs, uses RuboCop to find Ruby errors, creates annotations in a pull request, and automatically fixes linter errors. Next you might want to expand your app's code, deploy your app, and make your app public.</p>
<p>If you have any questions, start a <a href="https://github.com/orgs/community/discussions/categories/api-and-webhooks">GitHub Community discussion</a> in the API and Webhooks category.</p>
<h3><a href="#modify-the-app-code">Modify the app code</a></h3>
<p>This tutorial demonstrated how to create a "Fix this" button that is always displayed in pull requests in the repository. Try updating the code to display the "Fix this" button only when RuboCop finds errors.</p>
<p>If you'd prefer that RuboCop doesn't commit files directly to the head branch, update the code to instead create a pull request with a new branch that's based on the head branch.</p>
<h3><a href="#deploy-your-app">Deploy your app</a></h3>
<p>This tutorial demonstrated how to develop your app locally. When you are ready to deploy your app, you need to make changes to serve your app and keep your app's credential secure. The steps you take depend on the server that you use, but the following sections offer general guidance.</p>
<h4><a href="#host-your-app-on-a-server">Host your app on a server</a></h4>
<p>This tutorial used your computer or codespace as a server. Once the app is ready for production use, you should deploy your app to a dedicated server. For example, you can use <a href="https://azure.microsoft.com/products/app-service/">Azure App Service</a>.</p>
<h4><a href="#update-the-webhook-url">Update the webhook URL</a></h4>
<p>Once you have a server that is set up to receive webhook traffic from GitHub, update the webhook URL in your app settings. You should not use Smee.io to forward your webhooks in production.</p>
<h4><a href="#update-the-port-setting">Update the <code>:port</code> setting</a></h4>
<p>When you deploy your app, you will want to change the port where your server is listening. The code already tells your server to listen to all available network interfaces by setting <code>:bind</code> to <code>0.0.0.0</code>.</p>
<p>For example, you can set a <code>PORT</code> variable in your <code>.env</code> file on your server to indicate the port where your server should listen. Then, you can update the place where your code sets <code>:port</code> so that your server listens on your deployment port:</p>
<div>
<header><span>Ruby</span><pre>set :port, ENV['PORT']
</pre></header><pre><code>set <span>:port</span>, <span>ENV</span>[<span>'PORT'</span>]
</code></pre>
</div>
<h4><a href="#secure-your-apps-credentials">Secure your app's credentials</a></h4>
<p>You should never publicize your app's private key or webhook secret. This tutorial stored your app's credentials in a gitignored <code>.env</code> file. When you deploy your app, you should choose a secure way to store the credentials and update your code to get the value accordingly. For example, you can store the credentials with a secret management service like <a href="https://azure.microsoft.com/en-us/products/key-vault">Azure Key Vault</a>. When your app runs, it can retrieve the credentials and store them in environment variables on the server where your app is deployed.</p>
<p>For more information, see <a href="/en/apps/creating-github-apps/setting-up-a-github-app/best-practices-for-creating-a-github-app">Best practices for creating a GitHub App</a>.</p>
<h3><a href="#share-your-app">Share your app</a></h3>
<p>If you want to share your app with other users and organizations, make your app public. For more information, see <a href="/en/apps/creating-github-apps/creating-github-apps/making-a-github-app-public-or-private">Making a GitHub App public or private</a>.</p>
<h3><a href="#follow-best-practices">Follow best practices</a></h3>
<p>You should aim to follow best practices with your GitHub App. For more information, see <a href="/en/apps/creating-github-apps/setting-up-a-github-app/best-practices-for-creating-a-github-app">Best practices for creating a GitHub App</a>.</p>
</div></div></div>
</div>
</div></main>
</div></body></html>