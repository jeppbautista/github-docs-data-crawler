<html><body><div>
<main><div>
<div><nav><ul>
<li>
<a title="GitHub CLI" href="/en/github-cli">GitHub CLI</a><span>/</span>
</li>
<li>
<a title="GitHub CLI" href="/en/github-cli/github-cli">GitHub CLI</a><span>/</span>
</li>
<li><a title="Creating GitHub CLI extensions" href="/en/github-cli/github-cli/creating-github-cli-extensions">Creating GitHub CLI extensions</a></li>
</ul></nav></div>
<div>
<div><div><h1>Creating GitHub CLI extensions</h1></div></div>
<div><div><p>Learn how to share new GitHub CLI commands with other users by creating custom extensions for GitHub CLI.</p></div></div>
<div>
<h2>In this article</h2>
<nav><ul>
<li><a href="#about-github-cli-extensions"><div><span>About GitHub CLI extensions</span></div></a></li>
<li><a href="#creating-an-interpreted-extension-with-gh-extension-create"><div><span>Creating an interpreted extension with gh extension create</span></div></a></li>
<li><a href="#creating-a-precompiled-extension-in-go-with-gh-extension-create"><div><span>Creating a precompiled extension in Go with gh extension create</span></div></a></li>
<li><a href="#creating-a-non-go-precompiled-extension-with-gh-extension-create"><div><span>Creating a non-Go precompiled extension with gh extension create</span></div></a></li>
<li><a href="#creating-an-interpreted-extension-manually"><div><span>Creating an interpreted extension manually</span></div></a></li>
<li><a href="#tips-for-writing-interpreted-github-cli-extensions"><div><span>Tips for writing interpreted GitHub CLI extensions</span></div></a></li>
<li><a href="#creating-a-precompiled-extension-manually"><div><span>Creating a precompiled extension manually</span></div></a></li>
<li><a href="#tips-for-writing-precompiled-github-cli-extensions"><div><span>Tips for writing precompiled GitHub CLI extensions</span></div></a></li>
<li><a href="#next-steps"><div><span>Next steps</span></div></a></li>
</ul></nav>
</div>
<div><div><div>
<h2><a href="#about-github-cli-extensions">About GitHub CLI extensions</a></h2>
<p>GitHub CLI extensions are custom GitHub CLI commands that anyone can create and use. For more information about how to use GitHub CLI extensions, see <a href="/en/github-cli/github-cli/using-github-cli-extensions">Using GitHub CLI extensions</a>.</p>
<p>You need a repository for each extension that you create. The repository name must start with <code>gh-</code>. The rest of the repository name is the name of the extension. The repository must have an executable file at its root with the same name as the repository or a set of precompiled binary executables attached to a release.</p>
<div>
<p>
When relying on an executable script, we recommend using a bash script because bash is a widely available interpreter. You may use non-bash scripts, but the user must have the necessary interpreter installed in order to use the extension. If you would prefer to not rely on users having interpreters installed, consider a precompiled extension.</p>
</div>
<h2><a href="#creating-an-interpreted-extension-with-gh-extension-create">Creating an interpreted extension with <code>gh extension create</code></a></h2>
<div>
<p>
Running <code>gh extension create</code> with no arguments will start an interactive wizard.</p>
</div>
<p>You can use the <code>gh extension create</code> command to create a project for your extension, including a bash script that contains some starter code.</p>
<ol>
<li>
<p>Set up a new extension by using the <code>gh extension create</code> subcommand. Replace <code>EXTENSION-NAME</code> with the name of your extension.</p>
<pre><code>gh extension create EXTENSION-NAME
</code></pre>
</li>
<li>
<p>Follow the printed instructions to finalize and optionally publish your extension.</p>
</li>
</ol>
<h2><a href="#creating-a-precompiled-extension-in-go-with-gh-extension-create">Creating a precompiled extension in Go with <code>gh extension create</code></a></h2>
<p>You can use the <code>--precompiled=go</code> argument to create a Go-based project for your extension, including Go scaffolding, workflow scaffolding, and starter code.</p>
<ol>
<li>
<p>Set up a new extension by using the <code>gh extension create</code> subcommand. Replace <code>EXTENSION-NAME</code> with the name of your extension and specify <code>--precompiled=go</code>.</p>
<pre><code>gh extension create --precompiled=go EXTENSION-NAME
</code></pre>
</li>
<li>
<p>Follow the printed instructions to finalize and optionally publish your extension.</p>
</li>
</ol>
<h2><a href="#creating-a-non-go-precompiled-extension-with-gh-extension-create">Creating a non-Go precompiled extension with <code>gh extension create</code></a></h2>
<p>You can use the <code>--precompiled=other</code> argument to create a project for your non-Go precompiled extension, including workflow scaffolding.</p>
<ol>
<li>
<p>Set up a new extension by using the <code>gh extension create</code> subcommand. Replace <code>EXTENSION-NAME</code> with the name of your extension and specify <code>--precompiled=other</code>.</p>
<pre><code>gh extension create --precompiled=other EXTENSION-NAME
</code></pre>
</li>
<li>
<p>Add some initial code for your extension in your compiled language of choice.</p>
</li>
<li>
<p>Fill in <code>script/build.sh</code> with code to build your extension to ensure that your extension can be built automatically.</p>
</li>
<li>
<p>Follow the printed instructions to finalize and optionally publish your extension.</p>
</li>
</ol>
<h2><a href="#creating-an-interpreted-extension-manually">Creating an interpreted extension manually</a></h2>
<ol>
<li>
<p>Create a local directory called <code>gh-EXTENSION-NAME</code> for your extension. Replace <code>EXTENSION-NAME</code> with the name of your extension. For example, <code>gh-whoami</code>.</p>
</li>
<li>
<p>In the directory that you created, add an executable file with the same name as the directory.</p>
<div>
<p>
Make sure that your file is executable. On Unix, you can execute <code>chmod +x file_name</code> in the command line to make <code>file_name</code> executable. On Windows, you can run <code>git init -b main</code>, <code>git add file_name</code>, then <code>git update-index --chmod=+x file_name</code>.</p>
</div>
</li>
<li>
<p>Write your script in the executable file. For example:</p>
<pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -e
<span>exec</span> gh api user --jq <span>'"You are @\(.login) (\(.name))."'</span>
</code></pre>
</li>
<li>
<p>From your directory, install the extension as a local extension.</p>
<pre><code>gh extension install .
</code></pre>
</li>
<li>
<p>Verify that your extension works. Replace <code>EXTENSION-NAME</code> with the name of your extension. For example, <code>whoami</code>.</p>
<pre><code>gh EXTENSION-NAME
</code></pre>
</li>
<li>
<p>From your directory, create a repository to publish your extension. Replace <code>EXTENSION-NAME</code> with the name of your extension.</p>
<pre><code>git init -b main
git add . &amp;&amp; git commit -m "initial commit"
gh repo create gh-EXTENSION-NAME --source=. --public --push
</code></pre>
</li>
<li>
<p>Optionally, to help other users discover your extension, add the repository topic <code>gh-extension</code>. This will make the extension appear on the <a href="https://github.com/topics/gh-extension"><code>gh-extension</code> topic page</a>. For more information about how to add a repository topic, see <a href="/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/classifying-your-repository-with-topics">Classifying your repository with topics</a>.</p>
</li>
</ol>
<h2><a href="#tips-for-writing-interpreted-github-cli-extensions">Tips for writing interpreted GitHub CLI extensions</a></h2>
<h3><a href="#handling-arguments-and-flags">Handling arguments and flags</a></h3>
<p>All command line arguments following a <code>gh my-extension-name</code> command will be passed to the extension script. In a bash script, you can reference arguments with <code>$1</code>, <code>$2</code>, etc. You can use arguments to take user input or to modify the behavior of the script.</p>
<p>For example, this script handles multiple flags. When the script is called with the <code>-h</code> or <code>--help</code> flag, the script prints help text instead of continuing execution. When the script is called with the <code>--name</code> flag, the script sets the next value after the flag to <code>name_arg</code>. When the script is called with the <code>--verbose</code> flag, the script prints a different greeting.</p>
<pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -e

verbose=<span>""</span>
name_arg=<span>""</span>
<span>while</span> [ <span>$#</span> -gt 0 ]; <span>do</span>
  <span>case</span> <span>"<span>$1</span>"</span> <span>in</span>
  --verbose)
    verbose=1
    ;;
  --name)
    name_arg=<span>"<span>$2</span>"</span>
    <span>shift</span>
    ;;
  -h|--<span>help</span>)
    <span>echo</span> <span>"Add help text here."</span>
    <span>exit</span> 0
    ;;
  <span>esac</span>
  <span>shift</span>
<span>done</span>

<span>if</span> [ -z <span>"<span>$name_arg</span>"</span> ]
<span>then</span>
  <span>echo</span> <span>"You haven't told us your name."</span>
<span>elif</span> [ -z <span>"<span>$verbose</span>"</span> ]
<span>then</span>
  <span>echo</span> <span>"Hi <span>$name_arg</span>"</span>
<span>else</span>
  <span>echo</span> <span>"Hello and welcome, <span>$name_arg</span>"</span>
<span>fi</span>
</code></pre>
<h3><a href="#calling-core-commands-in-non-interactive-mode">Calling core commands in non-interactive mode</a></h3>
<p>Some GitHub CLI core commands will prompt the user for input. When scripting with those commands, a prompt is often undesirable. To avoid prompting, supply the necessary information explicitly via arguments.</p>
<p>For example, to create an issue programmatically, specify the title and body:</p>
<pre><code>gh issue create --title "My Title" --body "Issue description"
</code></pre>
<h3><a href="#fetching-data-programmatically">Fetching data programmatically</a></h3>
<p>Many core commands support the <code>--json</code> flag for fetching data programmatically. For example, to return a JSON object listing the number, title, and mergeability status of pull requests:</p>
<pre><code>gh pr list --json number,title,mergeStateStatus
</code></pre>
<p>If there is not a core command to fetch specific data from GitHub, you can use the <a href="https://cli.github.com/manual/gh_api"><code>gh api</code></a> command to access the GitHub API. For example, to fetch information about the current user:</p>
<pre><code>gh api user
</code></pre>
<p>All commands that output JSON data also have options to filter that data into something more immediately usable by scripts. For example, to get the current user's name:</p>
<pre><code>gh api user --jq '.name'
</code></pre>
<p>For more information, see <a href="https://cli.github.com/manual/gh_help_formatting"><code>gh help formatting</code></a>.</p>
<h2><a href="#creating-a-precompiled-extension-manually">Creating a precompiled extension manually</a></h2>
<ol>
<li>
<p>Create a local directory called <code>gh-EXTENSION-NAME</code> for your extension. Replace <code>EXTENSION-NAME</code> with the name of your extension. For example, <code>gh-whoami</code>.</p>
</li>
<li>
<p>In the directory you created, add some source code. For example:</p>
<pre><code><span>package</span> main
<span>import</span> (
  <span>"github.com/cli/go-gh"</span>
  <span>"fmt"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
  args := []<span>string</span>{<span>"api"</span>, <span>"user"</span>, <span>"--jq"</span>, <span>`"You are @\(.login) (\(.name))"`</span> }
  stdOut, _, err := gh.Exec(args...)
  <span>if</span> err != <span>nil</span> {
    fmt.Println(err)
    <span>return</span>
  }
  fmt.Println(stdOut.String())
}
</code></pre>
</li>
<li>
<p>From your directory, install the extension as a local extension.</p>
<pre><code>gh extension install .
</code></pre>
</li>
<li>
<p>Build your code. For example, with Go, replacing <code>YOUR-USERNAME</code> with your GitHub username:</p>
<pre><code>go mod init github.com/YOUR-USERNAME/gh-whoami
go mod tidy
go build
</code></pre>
</li>
<li>
<p>Verify that your extension works. Replace <code>EXTENSION-NAME</code> with the name of your extension. For example, <code>whoami</code>.</p>
<pre><code>gh EXTENSION-NAME
</code></pre>
</li>
<li>
<p>From your directory, create a repository to publish your extension. Replace <code>EXTENSION-NAME</code> with the name of your extension.</p>
<div>
<p>
Be careful not to commit the binary produced by your compilation step to version control.</p>
</div>
<pre><code> git init -b main
echo "gh-EXTENSION-NAME" &gt;&gt; .gitignore
git add main.go go.* .gitignore &amp;&amp; git commit -m 'Initial commit'
gh repo create "gh-EXTENSION-NAME"
</code></pre>
</li>
<li>
<p>Create a release to share your precompiled extension with others. Compile for each platform you want to support, attaching each binary to a release as an asset. Binary executables attached to releases must follow a naming convention and have a suffix of OS-ARCHITECTURE[EXTENSION].</p>
<p>For example, an extension named <code>whoami</code> compiled for Windows 64bit would have the name <code>gh-whoami-windows-amd64.exe</code> while the same extension compiled for Linux 32bit would have the name <code>gh-whoami-linux-386</code>. To see an exhaustive list of OS and architecture combinations recognized by <code>gh</code>, see <a href="https://github.com/cli/cli/blob/14f704fd0da58cc01413ee4ba16f13f27e33d15e/pkg/cmd/extension/manager.go#L696">this source code</a>.</p>
<div>
<p>
For your extension to run properly on Windows, its asset file must have a <code>.exe</code> extension. No extension is needed for other operating systems.</p>
</div>
<p>Releases can be created from the command line. For example:</p>
<pre><code>git tag v1.0.0
git push origin v1.0.0
GOOS=windows GOARCH=amd64 go build -o gh-EXTENSION-NAME-windows-amd64.exe
GOOS=linux GOARCH=amd64 go build -o gh-EXTENSION-NAME-linux-amd64
GOOS=darwin GOARCH=amd64 go build -o gh-EXTENSION-NAME-darwin-amd64
gh release create v1.0.0 ./*amd64*

</code></pre>
</li>
<li>
<p>Optionally, to help other users discover your extension, add the repository topic <code>gh-extension</code>. This will make the extension appear on the <a href="https://github.com/topics/gh-extension"><code>gh-extension</code> topic page</a>. For more information about how to add a repository topic, see <a href="/en/github/administering-a-repository/managing-repository-settings/classifying-your-repository-with-topics">Classifying your repository with topics</a>.</p>
</li>
</ol>
<h2><a href="#tips-for-writing-precompiled-github-cli-extensions">Tips for writing precompiled GitHub CLI extensions</a></h2>
<h3><a href="#automating-releases">Automating releases</a></h3>
<p>Consider adding the <a href="https://github.com/cli/gh-extension-precompile">gh-extension-precompile</a> action to a workflow in your project. This action will automatically produce cross-compiled Go binaries for your extension and supplies build scaffolding for non-Go precompiled extensions.</p>
<h3><a href="#using-github-cli-features-from-go-based-extensions">Using GitHub CLI features from Go-based extensions</a></h3>
<p>Consider using <a href="https://github.com/cli/go-gh">go-gh</a>, a Go library that exposes pieces of <code>gh</code> functionality for use in extensions.</p>
<h2><a href="#next-steps">Next steps</a></h2>
<p>To see more examples of GitHub CLI extensions, look at <a href="https://github.com/topics/gh-extension">repositories with the <code>gh-extension</code> topic</a>.</p>
</div></div></div>
</div>
</div></main>
</div></body></html>