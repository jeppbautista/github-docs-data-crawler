<html><body><div>
<main><div>
<div><nav><ul>
<li>
<a title="GitHub Copilot" href="/en/copilot">GitHub Copilot</a><span>/</span>
</li>
<li>
<a title="Copilot Chat Cookbook" href="/en/copilot/copilot-chat-cookbook">Copilot Chat Cookbook</a><span>/</span>
</li>
<li>
<a title="Documenting code" href="/en/copilot/copilot-chat-cookbook/documenting-code">Documenting code</a><span>/</span>
</li>
<li><a title="Explain complex logic" href="/en/copilot/copilot-chat-cookbook/documenting-code/explaining-complex-algorithms-or-logic">Explain complex logic</a></li>
</ul></nav></div>
<div>
<div><div><h1>Explaining complex algorithms or logic</h1></div></div>
<div><div><p>Copilot Chat can help add clear and concise documentation on complex algorithms or logic.</p></div></div>
<div>
<h2>In this article</h2>
<nav><ul>
<li><a href="#example-scenario"><div><span>Example scenario</span></div></a></li>
<li><a href="#example-prompt"><div><span>Example prompt</span></div></a></li>
<li><a href="#example-response"><div><span>Example response</span></div></a></li>
<li><a href="#further-reading"><div><span>Further reading</span></div></a></li>
</ul></nav>
</div>
<div><div><div>
<p>There may be times where you need to explain complex algorithms or logic in your code. This can be challenging, especially when you're trying to make it understandable to others. Copilot Chat can help you with this task by providing you with suggestions on how to explain the algorithm or logic in a clear and concise manner.</p>
<h2><a href="#example-scenario">Example scenario</a></h2>
<p>In the C# code below, we have a method which fetches data, retries if there's an error, and updates a status label. You might want to explain, in comments in the code, how the method works and how it handles retries and cancellations.</p>
<pre><code><span>private</span> <span>static</span> <span>readonly</span> HttpClient _client = <span>new</span> HttpClient();

<span><span>public</span> <span>async</span> Task&lt;<span>string</span>&gt; <span>FetchDataFromApiWithRetryAsync</span>(<span><span>string</span> apiUrl, CancellationToken cancellationToken, <span>int</span> maxRetries, <span>int</span> cancellationDelay, Label statusLabel</span>)</span>
{
    <span>var</span> retryCount = <span>0</span>;
    <span>using</span> <span>var</span> cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);

    <span>while</span> (retryCount &lt; maxRetries)
    {
        <span>try</span>
        {
            cts.CancelAfter(cancellationDelay);
            <span>return</span> <span>await</span> FetchDataFromApiAsync(cts.Token, statusLabel);
        }
        <span>catch</span> (Exception ex) <span>when</span> (!(ex <span>is</span> OperationCanceledException))
        {
            <span>if</span> (retryCount &lt; maxRetries - <span>1</span>) {
                retryCount++;
                <span>int</span> delay = (<span>int</span>)Math.Pow(<span>2</span>, retryCount) * <span>1000</span>;
                <span>await</span> Task.Delay(delay, cancellationToken);
                UpdateStatusLabel(<span>$"Retrying (<span>{retryCount}</span>/<span>{maxRetries}</span>)..."</span>, statusLabel);
            } <span>else</span> {
                <span>throw</span> <span>new</span> Exception(<span>$"Failed to fetch data after <span>{maxRetries}</span> retries: <span>{ex.Message}</span>"</span>, ex);
            }
        }
    }

    <span>throw</span> <span>new</span> OperationCanceledException(<span>"The operation was cancelled."</span>, cts.Token);
}

<span><span>private</span> <span>async</span> Task&lt;<span>string</span>&gt; <span>FetchDataFromApiAsync</span>(<span><span>string</span> apiUrl, CancellationToken cancellationToken, Label statusLabel</span>)</span>
{
    UpdateStatusLabel(<span>"Fetching data..."</span>, statusLabel);

    HttpResponseMessage response = <span>await</span> _client.GetAsync(apiUrl, cancellationToken);
    response.EnsureSuccessStatusCode();
    <span>string</span> data = <span>await</span> response.Content.ReadAsStringAsync();

    UpdateStatusLabel(<span>"Data fetched."</span>, statusLabel);
    <span>return</span> data;
}

<span><span>private</span> <span>void</span> <span>UpdateStatusLabel</span>(<span><span>string</span> message, Label statusLabel</span>)</span>
{
    <span>if</span> (statusLabel.InvokeRequired) {
        statusLabel.BeginInvoke(<span>new</span> Action&lt;<span>string</span>, Label&gt;(UpdateStatusLabel), message, statusLabel);
    } <span>else</span> {
        statusLabel.Text = message;
    }
}
</code></pre>
<h2><a href="#example-prompt">Example prompt</a></h2>
<p>We can ask Copilot Chat to make this code easier to understand using comments.</p>
<p><code>Add comments to this code to make it more understandable</code></p>
<h2><a href="#example-response">Example response</a></h2>
<div>
<p> The following response is an example. Copilot Chat responses are non-deterministic, so you may get a different response from the one shown here.</p>
</div>
<p>Copilot responds with an overview of the update it suggests, and the code snippet with the comments added:</p>
<pre><code><span>// Shared HttpClient instance for making HTTP requests (best practice for reuse)</span>
<span>private</span> <span>static</span> <span>readonly</span> HttpClient _client = <span>new</span> HttpClient();

<span><span>///</span> <span>&lt;summary&gt;</span></span>
<span><span>///</span> Fetches data from an API with retry mechanism and timeout functionality</span>
<span><span>///</span> <span>&lt;/summary&gt;</span></span>
<span><span>///</span> <span>&lt;param name="apiUrl"&gt;</span>The URL to fetch data from<span>&lt;/param&gt;</span></span>
<span><span>///</span> <span>&lt;param name="cancellationToken"&gt;</span>Token to cancel the operation<span>&lt;/param&gt;</span></span>
<span><span>///</span> <span>&lt;param name="maxRetries"&gt;</span>Maximum number of retry attempts<span>&lt;/param&gt;</span></span>
<span><span>///</span> <span>&lt;param name="cancellationDelay"&gt;</span>Timeout duration in milliseconds<span>&lt;/param&gt;</span></span>
<span><span>///</span> <span>&lt;param name="statusLabel"&gt;</span>UI label to show status updates<span>&lt;/param&gt;</span></span>
<span><span>public</span> <span>async</span> Task&lt;<span>string</span>&gt; <span>FetchDataFromApiWithRetryAsync</span>(<span><span>string</span> apiUrl, CancellationToken cancellationToken, <span>int</span> maxRetries, <span>int</span> cancellationDelay, Label statusLabel</span>)</span>
{
    <span>var</span> retryCount = <span>0</span>;
    <span>// Create a linked cancellation token that combines user cancellation and timeout</span>
    <span>using</span> <span>var</span> cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);

    <span>while</span> (retryCount &lt; maxRetries)
    {
        <span>try</span>
        {
            <span>// Set timeout for this attempt</span>
            cts.CancelAfter(cancellationDelay);
            <span>return</span> <span>await</span> FetchDataFromApiAsync(cts.Token, statusLabel);
        }
        <span>catch</span> (Exception ex) <span>when</span> (!(ex <span>is</span> OperationCanceledException))
        {
            <span>// If not the last retry attempt, implement exponential backoff</span>
            <span>if</span> (retryCount &lt; maxRetries - <span>1</span>) {
                retryCount++;
                <span>// Exponential backoff: 2^retryCount seconds (1s, 2s, 4s, 8s, etc.)</span>
                <span>int</span> delay = (<span>int</span>)Math.Pow(<span>2</span>, retryCount) * <span>1000</span>;
                <span>await</span> Task.Delay(delay, cancellationToken);
                UpdateStatusLabel(<span>$"Retrying (<span>{retryCount}</span>/<span>{maxRetries}</span>)..."</span>, statusLabel);
            } <span>else</span> {
                <span>// If all retries failed, throw exception with details</span>
                <span>throw</span> <span>new</span> Exception(<span>$"Failed to fetch data after <span>{maxRetries}</span> retries: <span>{ex.Message}</span>"</span>, ex);
            }
        }
    }

    <span>// This is reached if maxRetries is 0 or some other unexpected case</span>
    <span>throw</span> <span>new</span> OperationCanceledException(<span>"The operation was cancelled."</span>, cts.Token);
}

<span><span>///</span> <span>&lt;summary&gt;</span></span>
<span><span>///</span> Makes the actual API call to fetch data</span>
<span><span>///</span> <span>&lt;/summary&gt;</span></span>
<span><span>private</span> <span>async</span> Task&lt;<span>string</span>&gt; <span>FetchDataFromApiAsync</span>(<span><span>string</span> apiUrl, CancellationToken cancellationToken, Label statusLabel</span>)</span>
{
    UpdateStatusLabel(<span>"Fetching data..."</span>, statusLabel);

    <span>// Perform HTTP GET request with cancellation support</span>
    HttpResponseMessage response = <span>await</span> _client.GetAsync(apiUrl, cancellationToken);
    response.EnsureSuccessStatusCode(); <span>// Throws if response is not successful</span>
    <span>string</span> data = <span>await</span> response.Content.ReadAsStringAsync();

    UpdateStatusLabel(<span>"Data fetched."</span>, statusLabel);
    <span>return</span> data;
}

<span><span>///</span> <span>&lt;summary&gt;</span></span>
<span><span>///</span> Updates UI label text safely across threads</span>
<span><span>///</span> <span>&lt;/summary&gt;</span></span>
<span><span>///</span> <span>&lt;param name="message"&gt;</span>The message to display<span>&lt;/param&gt;</span></span>
<span><span>///</span> <span>&lt;param name="statusLabel"&gt;</span>The label control to update<span>&lt;/param&gt;</span></span>
<span><span>private</span> <span>void</span> <span>UpdateStatusLabel</span>(<span><span>string</span> message, Label statusLabel</span>)</span>
{
    <span>// Check if we need to invoke on UI thread</span>
    <span>if</span> (statusLabel.InvokeRequired) {
        <span>// Use BeginInvoke to update label on UI thread</span>
        statusLabel.BeginInvoke(<span>new</span> Action&lt;<span>string</span>, Label&gt;(UpdateStatusLabel), message, statusLabel);
    } <span>else</span> {
        <span>// Direct update if already on UI thread</span>
        statusLabel.Text = message;
    }
}
</code></pre>
<h2><a href="#further-reading">Further reading</a></h2>
<ul>
<li><a href="/en/copilot/using-github-copilot/prompt-engineering-for-github-copilot">Prompt engineering for Copilot Chat</a></li>
<li><a href="/en/copilot/using-github-copilot/best-practices-for-using-github-copilot">Best practices for using GitHub Copilot</a></li>
</ul>
</div></div></div>
</div>
</div></main>
</div></body></html>