<html><body><div>
<main><div>
<div><nav><ul>
<li>
<a title="GitHub Actions" href="/en/actions">GitHub Actions</a><span>/</span>
</li>
<li>
<a title="Write workflows" href="/en/actions/writing-workflows">Write workflows</a><span>/</span>
</li>
<li>
<a title="Choose what workflows do" href="/en/actions/writing-workflows/choosing-what-your-workflow-does">Choose what workflows do</a><span>/</span>
</li>
<li><a title="Cache dependencies" href="/en/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows">Cache dependencies</a></li>
</ul></nav></div>
<div>
<div><div><h1>Caching dependencies to speed up workflows</h1></div></div>
<div><div><p>To make your workflows faster and more efficient, you can create and use caches for dependencies and other commonly reused files.</p></div></div>
<div>
<h2>In this article</h2>
<nav><ul>
<li><a href="#about-caching-workflow-dependencies"><div><span>About caching workflow dependencies</span></div></a></li>
<li><a href="#comparing-artifacts-and-dependency-caching"><div><span>Comparing artifacts and dependency caching</span></div></a></li>
<li><a href="#restrictions-for-accessing-a-cache"><div><span>Restrictions for accessing a cache</span></div></a></li>
<li><a href="#using-the-cache-action"><div><span>Using the cache action</span></div></a></li>
<li><a href="#matching-a-cache-key"><div><span>Matching a cache key</span></div></a></li>
<li><a href="#usage-limits-and-eviction-policy"><div><span>Usage limits and eviction policy</span></div></a></li>
<li><a href="#managing-caches"><div><span>Managing caches</span></div></a></li>
</ul></nav>
</div>
<div><div><div>
<h2><a href="#about-caching-workflow-dependencies">About caching workflow dependencies</a></h2>
<p>Workflow runs often reuse the same outputs or downloaded dependencies from one run to another. For example, package and dependency management tools such as Maven, Gradle, npm, and Yarn keep a local cache of downloaded dependencies.</p>
<p>Jobs on GitHub-hosted runners start in a clean runner image and must download dependencies each time, causing increased network utilization, longer runtime, and increased cost. To help speed up the time it takes to recreate files like dependencies, GitHub can cache files you frequently use in workflows.</p>
<p>To cache dependencies for a job, you can use GitHub's <a href="https://github.com/actions/cache"><code>cache</code> action</a>. The action creates and restores a cache identified by a unique key. Alternatively, if you are caching the package managers listed below, using their respective setup-* actions requires minimal configuration and will create and restore dependency caches for you.</p>

































<table>
<thead><tr>
<th>Package managers</th>
<th>setup-* action for caching</th>
</tr></thead>
<tbody>
<tr>
<td>npm, Yarn, pnpm</td>
<td><a href="https://github.com/actions/setup-node#caching-global-packages-data">setup-node</a></td>
</tr>
<tr>
<td>pip, pipenv, Poetry</td>
<td><a href="https://github.com/actions/setup-python#caching-packages-dependencies">setup-python</a></td>
</tr>
<tr>
<td>Gradle, Maven</td>
<td><a href="https://github.com/actions/setup-java#caching-packages-dependencies">setup-java</a></td>
</tr>
<tr>
<td>RubyGems</td>
<td><a href="https://github.com/ruby/setup-ruby#caching-bundle-install-automatically">setup-ruby</a></td>
</tr>
<tr>
<td>Go <code>go.sum</code>
</td>
<td><a href="https://github.com/actions/setup-go#caching-dependency-files-and-build-outputs">setup-go</a></td>
</tr>
<tr>
<td>.NET NuGet</td>
<td><a href="https://github.com/actions/setup-dotnet?tab=readme-ov-file#caching-nuget-packages">setup-dotnet</a></td>
</tr>
</tbody>
</table>
<div>
<p>
Be mindful of the following when using caching with GitHub Actions:</p>
<ul>
<li>We recommend that you don't store any sensitive information in the cache. For example, sensitive information can include access tokens or login credentials stored in a file in the cache path. Also, command line interface (CLI) programs like <code>docker login</code> can save access credentials in a configuration file. Anyone with read access can create a pull request on a repository and access the contents of a cache. Forks of a repository can also create pull requests on the base branch and access caches on the base branch.</li>
<li>When using self-hosted runners, caches from workflow runs are stored on GitHub-owned cloud storage. A customer-owned storage solution is only available with GitHub Enterprise Server.</li>
</ul>
</div>
<h2><a href="#comparing-artifacts-and-dependency-caching">Comparing artifacts and dependency caching</a></h2>
<p>Artifacts and caching are similar because they provide the ability to store files on GitHub, but each feature offers different use cases and cannot be used interchangeably.</p>
<ul>
<li>Use caching when you want to reuse files that don't change often between jobs or workflow runs, such as build dependencies from a package management system.</li>
<li>Use artifacts when you want to save files produced by a job to view after a workflow run has ended, such as built binaries or build logs.</li>
</ul>
<p>For more information on workflow run artifacts, see <a href="/en/actions/using-workflows/storing-workflow-data-as-artifacts">Storing and sharing data from a workflow</a>.</p>
<h2><a href="#restrictions-for-accessing-a-cache">Restrictions for accessing a cache</a></h2>
<p>Access restrictions provide cache isolation and security by creating a logical boundary between different branches or tags.
Workflow runs can restore caches created in either the current branch or the default branch (usually <code>main</code>). If a workflow run is triggered for a pull request, it can also restore caches created in the base branch, including base branches of forked repositories. For example, if the branch <code>feature-b</code> has the base branch <code>feature-a</code>, a workflow run triggered on a pull request would have access to caches created in the default <code>main</code> branch, the base <code>feature-a</code> branch, and the current <code>feature-b</code> branch.</p>
<p>Workflow runs cannot restore caches created for child branches or sibling branches. For example, a cache created for the child <code>feature-b</code> branch would not be accessible to a workflow run triggered on the parent <code>main</code> branch. Similarly, a cache created for the <code>feature-a</code> branch with the base <code>main</code> would not be accessible to its sibling <code>feature-c</code> branch with the base <code>main</code>. Workflow runs also cannot restore caches created for different tag names. For example, a cache created for the tag <code>release-a</code> with the base <code>main</code> would not be accessible to a workflow run triggered for the tag <code>release-b</code> with the base <code>main</code>.</p>
<p>When a cache is created by a workflow run triggered on a pull request, the cache is created for the merge ref (<code>refs/pull/.../merge</code>). Because of this, the cache will have a limited scope and can only be restored by re-runs of the pull request. It cannot be restored by the base branch or other pull requests targeting that base branch.</p>
<p>Multiple workflow runs in a repository can share caches. A cache created for a branch in a workflow run can be accessed and restored from another workflow run for the same repository and branch.</p>
<h2><a href="#using-the-cache-action">Using the <code>cache</code> action</a></h2>
<p>The <a href="https://github.com/actions/cache"><code>cache</code> action</a> will attempt the following sequence when restoring a cache:</p>
<ol>
<li>First, it searches for an exact match to your provided <code>key</code>.</li>
<li>If no exact match is found, it will search for partial matches of the <code>key</code>.</li>
<li>If there is still no match found, and you've provided <code>restore-keys</code>, these keys will be checked sequentially for partial matches. For more information, see <a href="#matching-a-cache-key">Matching a cache key</a>.</li>
</ol>
<p>If there is an exact match to the provided <code>key</code>, this is considered a cache hit. If no cache exactly matches the provided <code>key</code>, this is considered a cache miss. On a cache miss, the action automatically creates a new cache if the job completes successfully. The new cache will use the <code>key</code> you provided and contains the files you specify in <code>path</code>. For more information about how this is handled, see <a href="#cache-hits-and-misses">Cache hits and misses</a>.</p>
<p>You cannot change the contents of an existing cache. Instead, you can create a new cache with a new key.</p>
<h3><a href="#input-parameters-for-the-cache-action">Input parameters for the <code>cache</code> action</a></h3>
<ul>
<li>
<p><code>key</code>: <strong>Required</strong> The key created when saving a cache and the key used to search for a cache. It can be any combination of variables, context values, static strings, and functions. Keys have a maximum length of 512 characters, and keys longer than the maximum length will cause the action to fail.</p>
</li>
<li>
<p><code>path</code>: <strong>Required</strong> The path(s) on the runner to cache or restore.</p>
<ul>
<li>
<p>You can specify a single path, or you can add multiple paths on separate lines. For example:</p>
<pre><code><span>-</span> <span>name:</span> <span>Cache</span> <span>Gradle</span> <span>packages</span>
  <span>uses:</span> <span>actions/cache@v4</span>
  <span>with:</span>
    <span>path:</span> <span>|
      ~/.gradle/caches
      ~/.gradle/wrapper
</span></code></pre>
</li>
<li>
<p>You can specify either directories or single files, and glob patterns are supported.</p>
</li>
<li>
<p>You can specify absolute paths, or paths relative to the workspace directory.</p>
</li>
</ul>
</li>
<li>
<p><code>restore-keys</code>: <strong>Optional</strong> A string containing alternative restore keys, with each restore key placed on a new line. If no cache hit occurs for <code>key</code>, these restore keys are used sequentially in the order provided to find and restore a cache. For example:</p>
<pre><code><span>restore-keys:</span> <span>|
  npm-feature-${{ hashFiles('package-lock.json') }}
  npm-feature-
  npm-
</span></code></pre>
</li>
<li>
<p><code>enableCrossOsArchive</code>: <strong>Optional</strong> A boolean value that when enabled, allows Windows runners to save or restore caches independent of the operating system the cache was created on. If this parameter is not set, it defaults to <code>false</code>. For more information, see <a href="https://github.com/actions/cache/blob/main/tips-and-workarounds.md#cross-os-cache">Cross OS cache</a> in the Actions Cache documentation.</p>
</li>
</ul>
<h3><a href="#output-parameters-for-the-cache-action">Output parameters for the <code>cache</code> action</a></h3>
<ul>
<li>
<code>cache-hit</code>: A boolean value to indicate an exact match was found for the key.</li>
</ul>
<h3><a href="#cache-hits-and-misses">Cache hits and misses</a></h3>
<p>When <code>key</code> exactly matches an existing cache, it's called a <em>cache hit</em>, and the action restores the cached files to the <code>path</code> directory.</p>
<p>When <code>key</code> doesn't match an existing cache, it's called a <em>cache miss</em>, and a new cache is automatically created if the job completes successfully.</p>
<p>When a cache miss occurs, the action also searches your specified <code>restore-keys</code> for any matches:</p>
<ol>
<li>If you provide <code>restore-keys</code>, the <code>cache</code> action sequentially searches for any caches that match the list of <code>restore-keys</code>.
<ul>
<li>When there is an exact match, the action restores the files in the cache to the <code>path</code> directory.</li>
<li>If there are no exact matches, the action searches for partial matches of the restore keys. When the action finds a partial match, the most recent cache is restored to the <code>path</code> directory.</li>
</ul>
</li>
<li>The <code>cache</code> action completes and the next step in the job runs.</li>
<li>If the job completes successfully, the action automatically creates a new cache with the contents of the <code>path</code> directory.</li>
</ol>
<p>For a more detailed explanation of the cache matching process, see <a href="#matching-a-cache-key">Matching a cache key</a>.</p>
<h3><a href="#example-using-the-cache-action">Example using the <code>cache</code> action</a></h3>
<p>This example creates a new cache when the packages in <code>package-lock.json</code> file change, or when the runner's operating system changes. The cache key uses contexts and expressions to generate a key that includes the runner's operating system and a SHA-256 hash of the <code>package-lock.json</code> file.</p>
<div>
<header><span>YAML</span><pre>name: Caching with npm
on: push
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Cache node modules
        id: cache-npm
        uses: actions/cache@v4
        env:
          cache-name: cache-node-modules
        with:
          # npm cache files are stored in `~/.npm` on Linux/macOS
          path: ~/.npm
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-
            ${{ runner.os }}-build-
            ${{ runner.os }}-

      - if: ${{ steps.cache-npm.outputs.cache-hit != 'true' }}
        name: List the state of node modules
        continue-on-error: true
        run: npm list

      - name: Install dependencies
        run: npm install

      - name: Build
        run: npm run build

      - name: Test
        run: npm test
</pre></header><pre><code><span>name:</span> <span>Caching</span> <span>with</span> <span>npm</span>
<span>on:</span> <span>push</span>
<span>jobs:</span>
  <span>build:</span>
    <span>runs-on:</span> <span>ubuntu-latest</span>
    <span>steps:</span>
      <span>-</span> <span>uses:</span> <span>actions/checkout@v4</span>

      <span>-</span> <span>name:</span> <span>Cache</span> <span>node</span> <span>modules</span>
        <span>id:</span> <span>cache-npm</span>
        <span>uses:</span> <span>actions/cache@v4</span>
        <span>env:</span>
          <span>cache-name:</span> <span>cache-node-modules</span>
        <span>with:</span>
          <span># npm cache files are stored in `~/.npm` on Linux/macOS</span>
          <span>path:</span> <span>~/.npm</span>
          <span>key:</span> <span>${{</span> <span>runner.os</span> <span>}}-build-${{</span> <span>env.cache-name</span> <span>}}-${{</span> <span>hashFiles('**/package-lock.json')</span> <span>}}</span>
          <span>restore-keys:</span> <span>|
            ${{ runner.os }}-build-${{ env.cache-name }}-
            ${{ runner.os }}-build-
            ${{ runner.os }}-
</span>
      <span>-</span> <span>if:</span> <span>${{</span> <span>steps.cache-npm.outputs.cache-hit</span> <span>!=</span> <span>'true'</span> <span>}}</span>
        <span>name:</span> <span>List</span> <span>the</span> <span>state</span> <span>of</span> <span>node</span> <span>modules</span>
        <span>continue-on-error:</span> <span>true</span>
        <span>run:</span> <span>npm</span> <span>list</span>

      <span>-</span> <span>name:</span> <span>Install</span> <span>dependencies</span>
        <span>run:</span> <span>npm</span> <span>install</span>

      <span>-</span> <span>name:</span> <span>Build</span>
        <span>run:</span> <span>npm</span> <span>run</span> <span>build</span>

      <span>-</span> <span>name:</span> <span>Test</span>
        <span>run:</span> <span>npm</span> <span>test</span>
</code></pre>
</div>
<h3><a href="#using-contexts-to-create-cache-keys">Using contexts to create cache keys</a></h3>
<p>A cache key can include any of the contexts, functions, literals, and operators supported by GitHub Actions. For more information, see <a href="/en/actions/learn-github-actions/contexts">Accessing contextual information about workflow runs</a> and <a href="/en/actions/learn-github-actions/expressions">Evaluate expressions in workflows and actions</a>.</p>
<p>Using expressions to create a <code>key</code> allows you to automatically create a new cache when dependencies change.</p>
<p>For example, you can create a <code>key</code> using an expression that calculates the hash of an npm <code>package-lock.json</code> file. So, when the dependencies that make up the <code>package-lock.json</code> file change, the cache key changes and a new cache is automatically created.</p>
<pre><code><span>npm-${{</span> <span>hashFiles('package-lock.json')</span> <span>}}</span>
</code></pre>
<p>GitHub evaluates the expression <code>hash "package-lock.json"</code> to derive the final <code>key</code>.</p>
<pre><code><span>npm-d5ea0750</span>
</code></pre>
<h3><a href="#using-the-output-of-the-cache-action">Using the output of the <code>cache</code> action</a></h3>
<p>You can use the output of the <code>cache</code> action to do something based on whether a cache hit or miss occurred. When an exact match is found for a cache for the specified <code>key</code>, the <code>cache-hit</code> output is set to <code>true</code>.</p>
<p>In the example workflow above, there is a step that lists the state of the Node modules if a cache miss occurred:</p>
<pre><code><span>-</span> <span>if:</span> <span>${{</span> <span>steps.cache-npm.outputs.cache-hit</span> <span>!=</span> <span>'true'</span> <span>}}</span>
  <span>name:</span> <span>List</span> <span>the</span> <span>state</span> <span>of</span> <span>node</span> <span>modules</span>
  <span>continue-on-error:</span> <span>true</span>
  <span>run:</span> <span>npm</span> <span>list</span>
</code></pre>
<h2><a href="#matching-a-cache-key">Matching a cache key</a></h2>
<p>The <code>cache</code> action first searches for cache hits for <code>key</code> and the cache <em>version</em> in the branch containing the workflow run. If there is no hit, it searches for prefix-matches for <code>key</code>, and if there is still no hit, it searches for <code>restore-keys</code> and the <em>version</em>. If there are still no hits in the current branch, the <code>cache</code> action retries the same steps on the default branch. Please note that the scope restrictions apply during the search. For more information, see <a href="#restrictions-for-accessing-a-cache">Restrictions for accessing a cache</a>.</p>
<p>Cache version is a way to stamp a cache with metadata of the <code>path</code> and the compression tool used while creating the cache. This ensures that the consuming workflow run uniquely matches a cache it can actually decompress and use. For more information, see <a href="https://github.com/actions/cache#cache-version">Cache Version</a> in the Actions Cache documentation.</p>
<p><code>restore-keys</code> allows you to specify a list of alternate restore keys to use when there is a cache miss on <code>key</code>. You can create multiple restore keys ordered from the most specific to least specific. The <code>cache</code> action searches the <code>restore-keys</code> in sequential order. When a key doesn't match directly, the action searches for keys prefixed with the restore key. If there are multiple partial matches for a restore key, the action returns the most recently created cache.</p>
<h3><a href="#example-using-multiple-restore-keys">Example using multiple restore keys</a></h3>
<pre><code><span>restore-keys:</span> <span>|
  npm-feature-${{ hashFiles('package-lock.json') }}
  npm-feature-
  npm-
</span></code></pre>
<p>The runner evaluates the expressions, which resolve to these <code>restore-keys</code>:</p>
<pre><code><span>restore-keys:</span> <span>|
  npm-feature-d5ea0750
  npm-feature-
  npm-
</span></code></pre>
<p>The restore key <code>npm-feature-</code> matches any key that starts with the string <code>npm-feature-</code>. For example, both of the keys <code>npm-feature-fd3052de</code> and <code>npm-feature-a9b253ff</code> match the restore key. The cache with the most recent creation date would be used. The keys in this example are searched in the following order:</p>
<ol>
<li>
<strong><code>npm-feature-d5ea0750</code></strong> matches a specific hash.</li>
<li>
<strong><code>npm-feature-</code></strong> matches cache keys prefixed with <code>npm-feature-</code>.</li>
<li>
<strong><code>npm-</code></strong> matches any keys prefixed with <code>npm-</code>.</li>
</ol>
<h4><a href="#example-of-search-priority">Example of search priority</a></h4>
<pre><code><span>key:</span>
  <span>npm-feature-d5ea0750</span>
<span>restore-keys:</span> <span>|
  npm-feature-
  npm-
</span></code></pre>
<p>For example, if a pull request contains a <code>feature</code> branch and targets the default branch (<code>main</code>), the action searches for <code>key</code> and <code>restore-keys</code> in the following order:</p>
<ol>
<li>Key <code>npm-feature-d5ea0750</code> in the <code>feature</code> branch</li>
<li>Key <code>npm-feature-</code> in the <code>feature</code> branch</li>
<li>Key <code>npm-</code> in the <code>feature</code> branch</li>
<li>Key <code>npm-feature-d5ea0750</code> in the <code>main</code> branch</li>
<li>Key <code>npm-feature-</code> in the <code>main</code> branch</li>
<li>Key <code>npm-</code> in the <code>main</code> branch</li>
</ol>
<h2><a href="#usage-limits-and-eviction-policy">Usage limits and eviction policy</a></h2>
<p>GitHub will remove any cache entries that have not been accessed in over 7 days. There is no limit on the number of caches you can store, but the total size of all caches in a repository is limited to 10 GB. Once a repository has reached its maximum cache storage, the cache eviction policy will create space by deleting the oldest caches in the repository.</p>
<p>If you exceed the limit, GitHub will save the new cache but will begin evicting caches until the total size is less than the repository limit. The cache eviction process may cause cache thrashing, where caches are created and deleted at a high frequency. To reduce this, you can review the caches for a repository and take corrective steps, such as removing caching from specific workflows. For more information, see <a href="#managing-caches">Managing caches</a>.</p>
<h2><a href="#managing-caches">Managing caches</a></h2>
<p>To manage caches created from your workflows, you can:</p>
<ul>
<li>View a list of all cache entries for a repository.</li>
<li>Filter and sort the list of caches using specific metadata such as cache size, creation time, or last accessed time.</li>
<li>Delete cache entries from a repository.</li>
<li>Monitor aggregate cache usage for repositories and organizations.</li>
</ul>
<p>There are multiple ways to manage caches for your repositories:</p>
<ul>
<li>
<p>Using the GitHub web interface, as shown below.</p>
</li>
<li>
<p>Using the REST API. For more information, see <a href="/en/rest/actions/cache">REST API endpoints for GitHub Actions cache</a>.</p>
</li>
<li>
<p>Installing the <code>gh cache</code> subcommand to manage your caches from the command line. For more information, see the <a href="https://cli.github.com/manual/gh_cache">GitHub CLI documentation</a>.</p>
<div>
<p>
If you are doing this manually, ensure you have version 2.32.0 or higher of the CLI installed.</p>
</div>
</li>
</ul>
<h3><a href="#viewing-cache-entries">Viewing cache entries</a></h3>
<p>You can use the web interface to view a list of cache entries for a repository. In the cache list, you can see how much disk space each cache is using, when the cache was created, and when the cache was last used.</p>
<ol>
<li>
<p>On GitHub, navigate to the main page of the repository.</p>
</li>
<li>
<p>Under your repository name, click </p>
<div><picture><source><img src="/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png" alt='Screenshot of the tabs for the "github/docs" repository. The "Actions" tab is highlighted with an orange outline.' width="1242" height="186"></source></picture></div>
</li>
<li>
<p>In the left sidebar, under the "Management" section, click </p>
</li>
<li>
<p>Review the list of cache entries for the repository.</p>
<ul>
<li>To search for cache entries used for a specific branch, click the <strong>Branch</strong> dropdown menu and select a branch. The cache list will display all of the caches used for the selected branch.</li>
<li>To search for cache entries with a specific cache key, use the syntax <code>key: key-name</code> in the <strong>Filter caches</strong> field. The cache list will display caches from all branches where the key was used.</li>
</ul>
<div><picture><source><img src="/assets/cb-33052/images/help/repository/actions-cache-entry-list.png" alt="Screenshot of the list of cache entries." width="698" height="220"></source></picture></div>
</li>
</ol>
<h3><a href="#deleting-cache-entries">Deleting cache entries</a></h3>
<p>Users with <code>write</code> access to a repository can use the GitHub web interface to delete cache entries.</p>
<ol>
<li>
<p>On GitHub, navigate to the main page of the repository.</p>
</li>
<li>
<p>Under your repository name, click </p>
<div><picture><source><img src="/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png" alt='Screenshot of the tabs for the "github/docs" repository. The "Actions" tab is highlighted with an orange outline.' width="1242" height="186"></source></picture></div>
</li>
<li>
<p>In the left sidebar, under the "Management" section, click </p>
</li>
<li>
<p>To the right of the cache entry you want to delete, click </p>
<div><picture><source><img src="/assets/cb-33457/images/help/repository/actions-cache-delete.png" alt="Screenshot of the list of cache entries. A trash can icon, used to delete a cache, is highlighted with a dark orange outline." width="698" height="220"></source></picture></div>
</li>
</ol>
<h3><a href="#force-deleting-cache-entries">Force deleting cache entries</a></h3>
<p>Caches have branch scope restrictions in place, which means some caches have limited usage options. For more information on cache scope restrictions, see <a href="#restrictions-for-accessing-a-cache">Restrictions for accessing a cache</a>, earlier in this article. If caches limited to a specific branch are using a lot of storage quota, it may cause caches from the <code>default</code> branch to be created and deleted at a high frequency.</p>
<p>For example, a repository could have many new pull requests opened, each with their own caches that are restricted to that branch. These caches could take up the majority of the cache storage for that repository. Once a repository has reached its maximum cache storage, the cache eviction policy will create space by deleting the oldest caches in the repository. In order to prevent cache thrashing when this happens, you can set up workflows to delete caches on a faster cadence than the cache eviction policy will. You can use the GitHub CLI to delete caches for specific branches.</p>
<p>The following example workflow uses <code>gh cache</code> to delete up to 100 caches created by a branch once a pull request is closed.</p>
<p>To run the following example on cross-repository pull requests or pull requests from forks, you can trigger the workflow with the <code>pull_request_target</code> event. If you do use <code>pull_request_target</code> to trigger the workflow, there are security considerations to keep in mind. For more information, see <a href="/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target">Events that trigger workflows</a>.</p>
<pre><code><span>name:</span> <span>cleanup</span> <span>caches</span> <span>by</span> <span>a</span> <span>branch</span>
<span>on:</span>
  <span>pull_request:</span>
    <span>types:</span>
      <span>-</span> <span>closed</span>

<span>jobs:</span>
  <span>cleanup:</span>
    <span>runs-on:</span> <span>ubuntu-latest</span>
    <span>permissions:</span>
      <span>actions:</span> <span>write</span>
    <span>steps:</span>
      <span>-</span> <span>name:</span> <span>Cleanup</span>
        <span>run:</span> <span>|
          echo "Fetching list of cache key"
          cacheKeysForPR=$(gh cache list --ref $BRANCH --limit 100 --json id --jq '.[].id')
</span>
          <span>## Setting this to not fail the workflow while deleting cache keys.</span>
          <span>set</span> <span>+e</span>
          <span>echo</span> <span>"Deleting caches..."</span>
          <span>for</span> <span>cacheKey</span> <span>in</span> <span>$cacheKeysForPR</span>
          <span>do</span>
              <span>gh</span> <span>cache</span> <span>delete</span> <span>$cacheKey</span>
          <span>done</span>
          <span>echo</span> <span>"Done"</span>
        <span>env:</span>
          <span>GH_TOKEN:</span> <span>${{</span> <span>secrets.GITHUB_TOKEN</span> <span>}}</span>
          <span>GH_REPO:</span> <span>${{</span> <span>github.repository</span> <span>}}</span>
          <span>BRANCH:</span> <span>refs/pull/${{</span> <span>github.event.pull_request.number</span> <span>}}/merge</span>
</code></pre>
<p>Alternatively, you can use the API to automatically list or delete all caches on your own cadence. For more information, see <a href="/en/rest/actions/cache#about-the-cache-in-github-actions">REST API endpoints for GitHub Actions cache</a>.</p>
</div></div></div>
</div>
</div></main>
</div></body></html>