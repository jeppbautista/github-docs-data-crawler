<html><body><div>
<main><div>
<div><nav><ul>
<li>
<a title="GitHub Copilot" href="/en/copilot">GitHub Copilot</a><span>/</span>
</li>
<li>
<a title="Use GitHub Copilot" href="/en/copilot/using-github-copilot">Use GitHub Copilot</a><span>/</span>
</li>
<li>
<a title="Guides" href="/en/copilot/using-github-copilot/guides-on-using-github-copilot">Guides</a><span>/</span>
</li>
<li><a title="Write tests" href="/en/copilot/using-github-copilot/guides-on-using-github-copilot/writing-tests-with-github-copilot">Write tests</a></li>
</ul></nav></div>
<div>
<div><div><h1>Writing tests with GitHub Copilot</h1></div></div>
<div><div><p>Use Copilot to generate unit and integration tests, and help improve code quality.</p></div></div>
<div>
<h2>In this article</h2>
<nav><ul>
<li><a href="#introduction"><div><span>Introduction</span></div></a></li>
<li><a href="#prerequisites"><div><span>Prerequisites</span></div></a></li>
<li><a href="#writing-unit-tests-with-copilot-chat"><div><span>Writing unit tests with Copilot Chat</span></div></a></li>
<li><a href="#writing-integration-tests-with-copilot"><div><span>Writing integration tests with Copilot</span></div></a></li>
<li><a href="#using-copilot-spaces-to-improve-test-suggestions"><div><span>Using Copilot Spaces to improve test suggestions</span></div></a></li>
</ul></nav>
</div>
<div><div><div>
<h2><a href="#introduction">Introduction</a></h2>
<p>GitHub Copilot can assist you in developing tests quickly and improving productivity. In this article, we’ll demonstrate how you can use Copilot to write both unit and integration tests. While Copilot performs well when generating tests for basic functions, complex scenarios require more detailed prompts and strategies. This article will walk through practical examples of using Copilot to break down tasks and verify code correctness.</p>
<h2><a href="#prerequisites">Prerequisites</a></h2>
<p>Before getting started you must have the following:</p>
<ul>
<li>A <a href="/en/copilot/about-github-copilot/subscription-plans-for-github-copilot">GitHub Copilot subscription plan</a>.</li>
<li>Visual Studio, Visual Studio Code, or any JetBrains IDE.</li>
<li>The <a href="/en/copilot/managing-copilot/configure-personal-settings/installing-the-github-copilot-extension-in-your-environment">GitHub Copilot extension</a> installed in your IDE.</li>
</ul>
<h2><a href="#writing-unit-tests-with-copilot-chat">Writing unit tests with Copilot Chat</a></h2>
<p>In this section, we’ll explore how to use GitHub Copilot Chat to generate unit tests for a Python class. This example demonstrates how you can use Copilot to create unit tests for a class like <code>BankAccount</code>. We will show you how to prompt Copilot to generate tests, execute them, and verify the results.</p>
<h3><a href="#example-class-bankaccount">Example class: <code>BankAccount</code></a></h3>
<p>Let’s start with a class <code>BankAccount</code> that contains methods for depositing, withdrawing, and getting the balance of an account. Create a new file <code>bank_account.py</code> in a GitHub repository and add the following <code>BankAccount</code> class in Python.</p>
<pre><code><span>class</span> <span>BankAccount</span>:
    <span>def</span> <span>__init__</span>(<span>self, initial_balance=<span>0</span></span>):
        <span>if</span> initial_balance &lt; <span>0</span>:
            <span>raise</span> ValueError(<span>"Initial balance cannot be negative."</span>)
        self.balance = initial_balance

    <span>def</span> <span>deposit</span>(<span>self, amount</span>):
        <span>if</span> amount &lt;= <span>0</span>:
            <span>raise</span> ValueError(<span>"Deposit amount must be positive."</span>)
        self.balance += amount

    <span>def</span> <span>withdraw</span>(<span>self, amount</span>):
        <span>if</span> amount &lt;= <span>0</span>:
            <span>raise</span> ValueError(<span>"Withdrawal amount must be positive."</span>)
        <span>if</span> amount &gt; self.balance:
            <span>raise</span> ValueError(<span>"Cannot withdraw more than the current balance."</span>)
        self.balance -= amount

    <span>def</span> <span>get_balance</span>(<span>self</span>):
        <span>return</span> self.balance
</code></pre>
<h3><a href="#generating-unit-tests-with-copilot-chat">Generating unit tests with Copilot Chat</a></h3>
<p>You can prompt Copilot with a request to write tests that cover a range of scenarios. Be specific with your test requirements to get the best results. The following is an example prompt you can use to generate unit tests for the <code>BankAccount</code> class.</p>
<p><strong>Prompt:</strong> <em>Develop a comprehensive suite of unit tests for the BankAccount() function in Python. Write multiple test methods that cover a wide range of scenarios, including edge cases, exception handling, and data validation.</em></p>
<p>This prompt does a few important things:</p>
<ul>
<li>
<strong>Scope:</strong> It explicitly asks for a comprehensive suite of unit tests, so that Copilot generates more than just basic tests, covering a variety of potential use cases.</li>
<li>
<strong>Scenarios:</strong> The prompt specifies that the tests should include:
<ul>
<li>
<strong>Edge cases:</strong> Tests for boundary conditions (e.g., negative values for deposits or withdrawals, withdrawing more than the available balance).</li>
<li>
<strong>Exception handling:</strong> Tests for errors that should be raised when certain invalid actions occur (e.g., withdrawing more than the available balance, depositing negative amounts).</li>
<li>
<strong>Data validation:</strong> Ensures that inputs are correctly validated and handled by the methods.</li>
</ul>
</li>
</ul>
<p>Copilot will give you a response like the following.</p>
<pre><code><span>import</span> unittest
<span>from</span> bank_account <span>import</span> BankAccount

<span>class</span> <span>TestBankAccount</span>(unittest.TestCase):
    <span>def</span> <span>setUp</span>(<span>self</span>):
        self.account = BankAccount()

    <span>def</span> <span>test_initial_balance</span>(<span>self</span>):
        self.assertEqual(self.account.get_balance(), <span>0</span>)

    <span>def</span> <span>test_deposit_positive_amount</span>(<span>self</span>):
        self.account.deposit(<span>100</span>)
        self.assertEqual(self.account.get_balance(), <span>100</span>)

    <span>def</span> <span>test_withdraw_within_balance</span>(<span>self</span>):
        self.account.deposit(<span>100</span>)
        self.account.withdraw(<span>50</span>)
        self.assertEqual(self.account.get_balance(), <span>50</span>)

    <span>def</span> <span>test_deposit_negative_amount_raises_error</span>(<span>self</span>):
        <span>with</span> self.assertRaises(ValueError):
            self.account.deposit(-<span>100</span>)

    <span>def</span> <span>test_withdraw_negative_amount_raises_error</span>(<span>self</span>):
        <span>with</span> self.assertRaises(ValueError):
            self.account.withdraw(-<span>50</span>)

    <span>def</span> <span>test_withdraw_more_than_balance_raises_error</span>(<span>self</span>):
        self.account.deposit(<span>100</span>)
        <span>with</span> self.assertRaises(ValueError):
            self.account.withdraw(<span>200</span>)

    <span>def</span> <span>test_initial_balance_negative_raises_error</span>(<span>self</span>):
        <span>with</span> self.assertRaises(ValueError):
            BankAccount(-<span>100</span>)

<span>if</span> __name__ == <span>'__main__'</span>:
    unittest.main()
</code></pre>
<h3><a href="#running-the-tests-cases">Running the tests cases</a></h3>
<p>The test suite generated by Copilot includes a test case for each scenario specified in the prompt. Each function in the <code>BankAccount</code> class is tested for a range of conditions, including valid operations like deposits and withdrawals, as well as edge cases such as negative amounts and attempts to withdraw more than the available balance.</p>
<p>Once Copilot has generated the test suite to your satisfaction, add the code to a new file <code>test_bank_account.py</code>. You can ask it how to run the tests.</p>
<p><strong>Prompt:</strong> <em>"How do I run these unit tests in Python using the unittest framework?"</em></p>
<p>Copilot will give you the following bash command.</p>
<pre><code>python -m unittest test_bank_account.py
</code></pre>
<p>After running the tests, you will see the output in your terminal or IDE. If all tests pass, you can be confident that your <code>BankAccount</code> class is working as expected.</p>
<h4><a href="#slash-command">Slash command</a></h4>
<p>Additionally, you can prompt Copilot to write a full suite of unit tests with the <code>/tests</code> slash command. Ensure that you have the file open on the current tab of your IDE and Copilot will generate unit tests for that file. The tests that Copilot generates may not cover all scenarios, so you should always review the generated code and add any additional tests that may be necessary.</p>
<div>
<p> If you ask Copilot to write tests for a code file that is not already covered by unit tests, you can provide Copilot with useful context by opening one or more existing test files in adjacent tabs in your editor. Copilot will be able to see the testing framework you use and will be more likely to write a test that is consistent with your existing tests.</p>
</div>
<p>Copilot will generate a unit test suite such as the following.</p>
<pre><code><span>import</span> unittest
<span>from</span> bank_account <span>import</span> BankAccount

<span>class</span> <span>TestBankAccount</span>(unittest.TestCase):
    <span>def</span> <span>setUp</span>(<span>self</span>):
        self.account = BankAccount()

    <span>def</span> <span>test_initial_balance</span>(<span>self</span>):
        self.assertEqual(self.account.get_balance(), <span>0</span>)
</code></pre>
<h2><a href="#writing-integration-tests-with-copilot">Writing integration tests with Copilot</a></h2>
<p>Integration tests are essential for ensuring that the various components of your system work correctly when combined. In this section, we’ll extend our <code>BankAccount</code> class to include interactions with an external service <code>NotificationSystem</code> and use mocks to test the system’s behavior without needing real connections. The goal of the integration tests is to verify the interaction between the <code>BankAccount</code> class and the <code>NotificationSystem</code> services, ensuring that they work together correctly.</p>
<h3><a href="#example-class-bankaccount-with-notification-services">Example class: <code>BankAccount</code> with notification services</a></h3>
<p>Let's update the <code>BankAccount</code> class to include interactions with an external service such as a <code>NotificationSystem</code> that sends notifications to users. <code>NotificationSystem</code> represents the integration that would need to be tested.</p>
<p>Update the <code>BankAccount</code> class in the <code>bank_account.py</code> file with the following code snippet.</p>
<pre><code><span>class</span> <span>BankAccount</span>:
    <span>def</span> <span>__init__</span>(<span>self, initial_balance=<span>0</span>, notification_system=<span>None</span></span>):
        <span>if</span> initial_balance &lt; <span>0</span>:
            <span>raise</span> ValueError(<span>"Initial balance cannot be negative."</span>)
        self.balance = initial_balance
        self.notification_system = notification_system

    <span>def</span> <span>deposit</span>(<span>self, amount</span>):
        <span>if</span> amount &lt;= <span>0</span>:
            <span>raise</span> ValueError(<span>"Deposit amount must be positive."</span>)
        self.balance += amount
        <span>if</span> self.notification_system:
            self.notification_system.notify(<span>f"Deposited <span>{amount}</span>, new balance: <span>{self.balance}</span>"</span>)

    <span>def</span> <span>withdraw</span>(<span>self, amount</span>):
        <span>if</span> amount &lt;= <span>0</span>:
            <span>raise</span> ValueError(<span>"Withdrawal amount must be positive."</span>)
        <span>if</span> amount &gt; self.balance:
            <span>raise</span> ValueError(<span>"Cannot withdraw more than the current balance."</span>)
        self.balance -= amount

        <span>if</span> self.notification_system:
            self.notification_system.notify(<span>f"Withdrew <span>{amount}</span>, new balance: <span>{self.balance}</span>"</span>)

    <span>def</span> <span>get_balance</span>(<span>self</span>):
        <span>return</span> self.balance
</code></pre>
<p>Here we'll break down our request for Copilot to write integration tests for the <code>BankAccount</code> class into smaller, more manageable pieces. This will help Copilot generate more accurate and relevant tests.</p>
<p><strong>Prompt:</strong> <em>"Write integration tests for the <code>deposit</code> function in the <code>BankAccount</code> class. Use mocks to simulate the <code>NotificationSystem</code> and verify that it is called correctly after a deposit."</em></p>
<p>This prompt does a few important things:</p>
<ul>
<li>
<strong>Scope:</strong> It specifies integration tests, focusing on the interaction between the <code>deposit</code> function and the <code>NotificationSystem</code>, rather than just unit tests.</li>
<li>
<strong>Mocks:</strong> It explicitly asks for the use of mocks to simulate the <code>NotificationSystem</code>, ensuring that the interaction with external systems is tested without relying on their actual implementation.</li>
<li>
<strong>Verification:</strong> The prompt emphasizes verifying that the <code>NotificationSystem</code> is called correctly after a deposit, ensuring that the integration between the components works as expected.</li>
<li>
<strong>Specificity:</strong> The prompt clearly states the method (<code>deposit</code>) and the class (<code>BankAccount</code>) to be tested.</li>
</ul>
<div>
<p> If Copilot is producing invalid tests, provide examples of inputs and outputs for the function you want to test. This will help Copilot evaluate the expected behavior of the function.</p>
</div>
<p>Copilot will generate a test suite like the following.</p>
<pre><code><span>import</span> unittest
<span>from</span> unittest.mock <span>import</span> Mock
<span>from</span> bank_account <span>import</span> BankAccount

<span>class</span> <span>TestBankAccountIntegration</span>(unittest.TestCase):
    <span>def</span> <span>setUp</span>(<span>self</span>):
        self.notification_system = Mock()

    <span>def</span> <span>test_deposit_with_notification</span>(<span>self</span>):
        account = BankAccount(initial_balance=<span>100</span>, notification_system=self.notification_system)
        account.deposit(<span>50</span>)
        self.assertEqual(account.get_balance(), <span>150</span>)
        self.notification_system.notify.assert_called_once_with(<span>"Deposited 50, new balance: 150"</span>)

<span>if</span> __name__ == <span>'__main__'</span>:
    unittest.main()
</code></pre>
<p>Add the generated code to a new file <code>test_bank_account_integration.py</code>.</p>
<h3><a href="#improving-on-the-test-cases">Improving on the test cases</a></h3>
<p>The prompt above generated a single test case that verifies the <code>NotificationSystem</code> is called when a valid deposit is made. However, it doesn't cover cases where an error is raised during the deposit. In those scenarios, the <code>NotificationSystem</code> should not be called. We need to add a test case that handles invalid deposits and ensure the notification system is not triggered.</p>
<p><strong>Prompt:</strong> <em>"Add a test case for invalid deposit amounts to verify the function raises the correct exceptions and that the <code>NotificationService</code> is not called."</em></p>
<p>Copilot will generate a test case such as the following.</p>
<pre><code>    <span>def</span> <span>test_deposit_negative_amount_raises_error</span>(<span>self</span>):
        account = BankAccount(initial_balance=<span>100</span>, notification_system=self.notification_system)
        <span>with</span> self.assertRaises(ValueError):
            account.deposit(<span>0</span>)
        self.notification_system.notify.assert_not_called()
</code></pre>
<h3><a href="#asking-about-areas-of-improvement">Asking about areas of improvement</a></h3>
<p>Now that we've written test cases to validate the integration functionality for deposits, this is a great opportunity to search for improvements within the test suite. While the current tests are functional, we can prompt Copilot to evalulate code coverage and suggest areas of improvement.</p>
<p><strong>Prompt:</strong> <em>"What additional tests should be included to ensure full coverage for the integration between the <code>BankAccount</code> class and the <code>NotificationSystem</code>?"</em></p>
<p>Prompting Copilot with this question can help you identify missing test cases that may have been overlooked.
In this situation, while we tested valid and invalid deposits, we haven't yet covered the withdrawal functionality.</p>
<p>Copilot will generate an updated test suite such as the following.</p>
<details>
  <summary>Click to expand the full generated code example</summary>
<pre><code><span>import</span> unittest
<span>from</span> unittest.mock <span>import</span> Mock
<span>from</span> bank_account <span>import</span> BankAccount

<span>class</span> <span>TestBankAccountIntegration</span>(unittest.TestCase):
    <span>def</span> <span>setUp</span>(<span>self</span>):
        self.notification_system = Mock()

    <span>def</span> <span>test_deposit_with_notification</span>(<span>self</span>):
        account = BankAccount(initial_balance=<span>100</span>, notification_system=self.notification_system)
        account.deposit(<span>50</span>)
        self.assertEqual(account.get_balance(), <span>150</span>)
        self.notification_system.notify.assert_called_once_with(<span>"Deposited 50, new balance: 150"</span>)

    <span>def</span> <span>test_deposit_negative_amount_raises_error</span>(<span>self</span>):
        account = BankAccount(initial_balance=<span>100</span>, notification_system=self.notification_system)
        <span>with</span> self.assertRaises(ValueError):
            account.deposit(-<span>50</span>)
        self.notification_system.notify.assert_not_called()

    <span>def</span> <span>test_deposit_zero_amount_raises_error</span>(<span>self</span>):
        account = BankAccount(initial_balance=<span>100</span>, notification_system=self.notification_system)
        <span>with</span> self.assertRaises(ValueError):
            account.deposit(<span>0</span>)
        self.notification_system.notify.assert_not_called()

    <span>def</span> <span>test_withdraw_with_notification</span>(<span>self</span>):
        account = BankAccount(initial_balance=<span>100</span>, notification_system=self.notification_system)
        account.withdraw(<span>30</span>)
        self.assertEqual(account.get_balance(), <span>70</span>)
        self.notification_system.notify.assert_called_once_with(<span>"Withdrew 30, new balance: 70"</span>)

    <span>def</span> <span>test_withdraw_exceeding_balance_raises_error</span>(<span>self</span>):
        account = BankAccount(initial_balance=<span>100</span>, notification_system=self.notification_system)
        <span>with</span> self.assertRaises(ValueError):
            account.withdraw(<span>150</span>)
        self.notification_system.notify.assert_not_called()

    <span>def</span> <span>test_withdraw_negative_amount_raises_error</span>(<span>self</span>):
        account = BankAccount(initial_balance=<span>100</span>, notification_system=self.notification_system)
        <span>with</span> self.assertRaises(ValueError):
            account.withdraw(-<span>30</span>)
        self.notification_system.notify.assert_not_called()

    <span>def</span> <span>test_withdraw_zero_amount_raises_error</span>(<span>self</span>):
        account = BankAccount(initial_balance=<span>100</span>, notification_system=self.notification_system)
        <span>with</span> self.assertRaises(ValueError):
            account.withdraw(<span>0</span>)
        self.notification_system.notify.assert_not_called()

    <span>def</span> <span>test_initial_negative_balance_raises_error</span>(<span>self</span>):
        <span>with</span> self.assertRaises(ValueError):
            BankAccount(initial_balance=-<span>100</span>, notification_system=self.notification_system)

<span>if</span> __name__ == <span>'__main__'</span>:
    unittest.main()
</code></pre>
</details>
<p>Once Copilot has generated the test suite to your satisfaction, run the tests with command below to verify the results.</p>
<pre><code>python -m unittest test_bank_account_integration.py
</code></pre>
<h2><a href="#using-copilot-spaces-to-improve-test-suggestions">Using Copilot Spaces to improve test suggestions</a></h2>
<p>Copilot Spaces is a feature that allows you to organize and share task-specific context with Copilot. This can help improve the relevance of the suggestions you receive. By providing Copilot with more context about your project, you can get better test suggestions.</p>
<p>For example, you could create a space that includes:</p>
<ul>
<li>The module you’re testing (like <code>payments.js</code>)</li>
<li>The current test suite (like <code>payments.test.js</code>)</li>
<li>A test coverage report or notes about what's missing</li>
</ul>
<p>In the space, you can ask Copilot questions like:</p>
<blockquote>
<p>What test cases are missing in <code>payments.test.js</code> based on the logic in <code>payments.js</code>?</p>
</blockquote>
<p>Or:</p>
<blockquote>
<p>Write a unit test for the refund logic in <code>refund.js</code>, following the structure in the existing test suite.</p>
</blockquote>
<p>For more information about using Copilot Spaces, see <a href="/en/copilot/using-github-copilot/copilot-spaces/about-organizing-and-sharing-context-with-copilot-spaces">About organizing and sharing context with Copilot Spaces</a>.</p>
</div></div></div>
</div>
</div></main>
</div></body></html>